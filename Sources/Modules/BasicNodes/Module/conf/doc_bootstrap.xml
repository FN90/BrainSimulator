<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GoodAI.BasicNodes</name>
    </assembly>
    <members>
        <member name="T:GoodAI.Modules.Common.MultiplexerNode">
            <author>GoodAI</author>
            <meta>mv</meta>
            <status>Working</status>
            <summary>Provides simple pattern-based data routing</summary>
            <description>Node, which routes input data to its output by a given pattern.</description>
        </member>
        <member name="T:GoodAI.Modules.Common.MultiplexerNode.RoutingTask">
            <summary>
            <br>Each number defines, for how long the given input will be copied to output. </br>
            
            <br>E.g. - if you enter: 500,200,500 then for the first 500 steps, Input 1 will be copied into output, for next 200 steps Input 2 will be copied into output and then Input 3 will be copied into output for another 500 steps.</br>
            
            <br>After that, 0 will be set as output or pattern will be applied again (according to Rotate param). </br>
            
            <br>You can enter negative numbers too - they define, for how long output will be filled with 0. So -1000,500,200,-300,-100,500 is valid pattern too. </br>
            
            <br>You can enter zero as well - that means that you want to skip whichever input should be that number for. Therefore 100,0,50 will output only first and third input</br>
            
            <br>Pattern can be longer than number of inputs. 
            E.g. pattern -200,1000,-200,-200,0,1000,300,400,-200,600 with 3 inputs will route inputs: none, 1, none, 3, 1, 2, 3.</br>
            
            <br>While pattern which is shorter, will triger only the starting inputs. 
            E.g. pattern -200,1000,100 with 3 inputs will give you only the first two into output.</br>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Common.BoxPlotNode">
            <author>GoodAI</author>
            <meta>ms</meta>
            <status>Working</status>
            <summary> For given data returns 5-tuple (Min, FirstQuartile, Median, ThirdQuartile, Max). </summary>
            <description>
            <p>5-tuples are in rows (ColumnHint = 5). </p>
            There are four modes of input processing: 
            <ul> 
            <li>Take data from whole input matrix: CalculateFor = <b>WholeMatrix</b></li>
            <li>Take data from rows: CalculateFor = <b>Rows</b></li>
            <li>Take data from columns: CalculateFor = <b>Columns</b></li>
            <li>Take data for every element from time-collecting window: CalculateFor = <b>AllElements</b>; WindowLength = <b>X</b> >= 3</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Common.BoxPlotNode.BoxPlotTask">
            <summary>Returns 5-tuple (Min, FirstQuartile, Median, ThirdQuartile, Max).</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.MyConditionalGate">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>A node for gating signals from two input branches based on current iteration.</summary>
            <description>
            If the iteration is lower than the parameter value, Input1 is copied to the Output. 
            Interation counter is increased each iteration and is reset at each time step. 
            Can be used in the LoopGroup for conditional gating of two signals AND/OR for providing the current iteration number.
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.Common.MyConditionalGate.MyCountInterationsTask">
            <summary>
            At each call, the Interation counter is increased by 1. The counter is reset at each change of SimulationStep.
            
            <br>Note that use of this gate in multiple nested LoopGroups (and/or any group with custom task planning) can lead to unexpected behavior, 
            since the Iteration coutner is reser only on -change- of simulation step.</br>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Common.MyConditionalGate.MyGateTask">
            <summary>
            Performs gating based on counter how many times has been called during this simulation step.
            If Iteration lower than IterationThreshold, copy Input1 to the Output, Input2 otherwise. Iteration is reset each time step.
            Inputs do not have to be connected at all.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Common.MyLoopGroup">
            <author>GoodAI</author>
            <meta>mv</meta>
            <status>Working</status>
            <summary>
            Group that runs all Nodes inside multiple times per one simulation step. 
            </summary>
            <description>
            Run all Nodes inside multiple times per step.
            <h3>Parameters</h3>
            <ul>
                <li> <b>Iterations:</b> How many Iterations to run everything inside at one SimulationStep.</li>
                <li> <b>LoopType:</b> "Normal" mode will use the default plan, "All" means that LoopGroup will run OneShot tasks too.</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Common.StatisticsNode">
            <author>GoodAI</author>
            <meta>ms</meta>
            <status>Working</status>
            <summary>Calculates statistical paramters.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Common.StatisticsNode.MeanTask">
            <summary>Returns mean for each element of matrix through time window, row, column or total.
            If used with Window > 1, first process rows/columns/all, then process over window.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.StatisticsNode.VarianceTask">
            <summary>Returns variances for rows, column or total. If used with Window > 1, first process rows/columns/all, then process over window.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.StatisticsNode.ModeTask">
            <summary>Returns the most frequent value for every element through time window, rows, columns or total.
            If used with Window > 1, first process rows/columns/all, then process over window.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.MyCsvFileWriterNode">
            <author>GoodAI</author>
            <meta>js</meta>
            <status>Working</status>
            <summary>Node for generating CSV files. </summary>
            <description>The generated file starts with (possibly several lines of) headers
            copied from the property "Headers". Then every other line contains consecutively:
            the time step, the label and input value (formatted according to the property
            "InputValueWriteFormat" and separated by the property "ListSeparator").
            One line corresponds to one data point.
            </description>
        </member>
        <member name="T:GoodAI.Modules.Common.MyInverseTransformSampling">
            <author>GoodAI</author>
            <meta>mb</meta>
            <status>Working</status>
            <summary>Generates sample from given distribution</summary>
            <description>Uses simple <a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">Inverse transform sampling</a></description>
        </member>
        <member name="T:GoodAI.Modules.Common.MyInverseTransformSampling.MyITSTask">
            <description>Implements Inverse transform sampling</description>
        </member>
        <member name="T:GoodAI.Modules.Common.MyRandomNode">
            <author>GoodAI</author>
            <meta>mv</meta>
            <status>Working</status>
            <summary>Generates numbers from chosen distribution</summary>
            <description>The <b>SingleOutput</b> property will set random number on one (random) element of Output mem. block only.</description>
        </member>
        <member name="T:GoodAI.Modules.Common.PeriodRNGTask">
            <summary>This task holds information about period. Period information is in the task, so it can be changed during runtime.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.UniformRNGTask">
            <summary>Generates numbers from uniform distribution. Number will be in interval from MinValue to MaxValue.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.NormalRNGTask">
            <summary>Generates numbers from normal distribution with parameters specified by Mean and StdDev.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.ConstantRNGTask">
            <summary>Generates constant number.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.CombinationRNGTask">
            <summary>Generates (possibly unique) integers between Min and Max where Min is inclusive and Max is exclusive.</summary>
        </member>
        <member name="T:GoodAI.Modules.Common.MyGenerateInput">
            <author>GoodAI</author>
            <meta>mb</meta>
            <status>Working</status>
            <summary>Samples a linear function values to the output array. 
            The output is shifted each step by ShiftSpeed parameter.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Common.MyGenerateInput.MyTransferTask">
            <summary>Generates input. Possible methods are:<dl>
            <dt><b>Linear</b></dt><dd>Set output to numbers spread evenly between <b>MinValue</b> and <b>MaxValue</b> (including) and shifts them each step by <b>ShiftSpeed</b> positions. If the output size is 1, MinValue will be set as output.</dd>
            <dt><b>Sine</b></dt><dd>Sets first output element to sine of 2*Pi*SimulationStep*UserInput. Therefore first value in UserInput serves as inverse "sampling frequency". Setting it to 1 or 0.5 will give you just zeros while setting it to 0.01 will spread one sine period to 100 simulation steps.</dd>
            <dt><b>Cosine</b></dt><dd>Sets first output element to cosine of 2*Pi*SimulationStep*UserInput. Therefore first value in UserInput serves as inverse "sampling frequency". Setting it to 1 will give you just ones while setting it to 0.01 will spread one cosine period to 100 simulation steps.</dd>
            <dt><b>UserData</b></dt><dd>Data in node's <b>UserInput</b> are copied into output</dd>
            <dt><b>SimulationStep</b></dt><dd>Output is set to current simulation step number</dd>
            <dt><b>SimulationStepFce</b></dt><dd>Task cyclically iterates over node's UserInput and puts values from it to output</dd>
            </dl></summary>
        </member>
        <member name="T:GoodAI.Modules.DiscreteRL.Observers.DiscretePolicyObserver`1">
            <author>GoodAI</author>
            <meta>df,jv,pd</meta>
            <status>WIP</status>
            <summary>
            Observes some policy which maps states to actions.
            </summary>
            <typeparam name="T">Node which uses some policy</typeparam>
        </member>
        <member name="M:GoodAI.Modules.DiscreteRL.Observers.DiscretePolicyObserver`1.MatrixSizeOK">
            <summary>
            Is not OK either if both dimensions have zero size or the total size of matrix is too big for GPU mem
            </summary>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.DiscreteRL.Observers.DiscreteQLearningObserver">
            <summary>
            Observer for the DiscreteQLearning, specifies the generic type of DiscretePolicyObserver.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.DiscreteRL.Observers.DiscreteSRPObserver">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Observers SRPs (Stochastic Return Predictors) in the HARM (each one has name, own motivation, promoted variable etc..).
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Input">
            <summary>
            Input of the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Output">
            <summary>
            Output of the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Slope_μ">
            <summary>
            Slope of LTD eligibility trace 
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Slope_λ">
            <summary>
            Slope of LTP eligibility trace
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.DelayInterval">
            <summary>
            Interval of axonal conduction delays. The actual conduction delay of each FIFO queue is sampled from this interval.
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.MaximumLearningRate">
            <summary>
            Initial Learning rate η0 of the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Temperature_τ">
            <summary>
            Temperature of the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.LearningRateCorection_M">
            <summary>
            Number of iterations for log-likelihood collection until learning rate update
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Fifo_x">
            <summary>
            One FIFO queue for each synapse between neurons
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Bias_b">
            <summary>
            Each neurons bias. Large positive bias makes neuron most likely to spike.
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Energy_E">
            <summary>
            Energy of each neuron at time t
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Delay_d">
            <summary>
            Conduction delay of each synapse
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Weight_u">
            <summary>
            One Long-Term Potentiation weight for each synapse
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Weight_v">
            <summary>
            One Long-Term Depresion weight for each synapse
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Trace_α">
            <summary>
            Long-Term Potentiation eligibility trace
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Trace_β">
            <summary>
            Long-Term Depresion eligibility trace, only considering spikes within period of Conduction delay
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Trace_γ">
            <summary>
            Long-Term Depresion eligibility trace, considering spikes after Conduction delay
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.FIFO_trace">
            <summary>
            FIFO traces for each synapse
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.LearningRate_η">
            <summary>
            Adjustable learning rate for each parameter θ using AdaGrad.
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.LogLikelihood">
            <summary>
            Log-likelihood
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Derivative_Δ">
            <summary>
            Log-likelihood derivate for Learning rate update
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Neurons">
            <summary>
            Number of neurons within the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Synapses">
            <summary>
            Number of synapses within the Layer
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Traces_K">
            <summary>
            Number of eligibility traces for each synapse based on parameters
            </summary>
        </member>
        <member name="P:GoodAI.Modules.DyBM.MyDyBMInputLayer.Traces_L">
            <summary>
            Number of eligibility traces for each neuron based on parameters
            </summary>
        </member>
        <member name="M:GoodAI.Modules.DyBM.MyDyBMInputLayer.#ctor">
            <summary>
            Constructor of DyBMInputLayer class
            </summary>
        </member>
        <member name="T:GoodAI.Modules.DyBM.Tasks.MyDyBMLearningTask">
            <summary>
            Layer learning task
            </summary>
        </member>
        <member name="M:GoodAI.Modules.DyBM.Tasks.MyDyBMLearningTask.Init(System.Int32)">
            <summary>
            Initialize all parameters to 0 -> meaning that previous sequences were all 0
            </summary>
            <param name="nGPU"></param>
        </member>
        <member name="M:GoodAI.Modules.DyBM.Tasks.MyDyBMLearningTask.Execute">
            <summary>
            Execute one learning step of the layer through all neurons
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyTwoPlayerPongWorld">
            <author>GoodAI</author>
            <meta>mp</meta>
            <status>Working</status>
            <summary>Custom implementation of pong for two players.</summary>
            <description>Modifies CustomPongWorld by adding a second player. There are no bricks, just two paddles and a ball.
            Inspired by the <a href="https://en.wikipedia.org/wiki/Pong">original pong</a>.
            
            <h3>Controls - Player A</h3>
            <ol>
            <li>Go left</li>
            <li>Stop</li>
            <li>Go right</li>
            </ol>
            
            <h3>ControlsB - Player B</h3>
            <ol>
            <li>Go left</li>
            <li>Stop</li>
            <li>Go right</li>
            </ol>
            
            BinaryEvent output has a vector of binary events as follows: "bounce ball", "opponent lost life", "lost life".<br />
            
            Event output has values defined by UpdateTwoPlayerTask's parameters.<br />
            
            PaddlePos, Event and BinaryEvent outputs are present twice, once for each of the players (A,B)<br />
            </description>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyTwoPlayerPongWorld.MyInitTwoPlayerTask">
            <summary>
            Loads textures, prepares game objects.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyTwoPlayerPongWorld.MyUpdateTwoPlayerTask">
            <summary>
            Updates the game's state based on inputs. It allows configuration of Event output through properties.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.My2DAgentWorld">
            <author>GoodAI</author>
            <meta>df,jv</meta>
            <status>Working</status>
            <summary>Simple 2D topview world with agent and target.</summary>
            <description>Agent and target positions are available. Agent moves continuously in the 2D environment. 
            Movement is controlled by 9 values (8 directions + no operation), which change velocity in the corresponding direction. 
            The goal is to reach the target, if target is reached, the event signal is sent and goal is placed onto new randomly generated position.
            </description>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.My2DAgentWorld.MyInitTask">
            <summary>
            Initialize the simulation, load bitmaps.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.My2DAgentWorld.MyRenderTask">
            <summary>
            Render the world to the visual output.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.My2DAgentWorld.MyUpdateTask">
            <summary>
            Receive agent's action, apply the world rules and publish new state.
            
            <description>
            <h3>Parameters</h3>
            <ul>
                <li> <b>ReachTargetSignal: </b>This value is set to the Event output for one time step, if the target is reached.</li>
                <li> <b>AgentVelocity: </b>How fast the agent moves.</li>
                <li> <b>DeltaT: </b>Time shift at each simulation step.</li>
                <li> <b>TargetRadius: </b>Radius in which the target is considered as reached.</li>
                <li> <b>ResetCountouwnSteps: </b>How many steps after reaching the target to wait before generating new target.</li>
                <li> <b>ForcePosition: </b>After reaching the target, new position is generated. If true, position is forced to be constant.</li>
            </ul>
            
            </description>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyCustomPongWorld">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>Custom implementation of the pong (arkanoid) game.</summary>
            <description>Follows the original game boy EVA pong game (same graphics &amp; levels). Bricks can be turned on and off. 
            Ball can be fired in arbitrary direction. It is faster.
            
            <h3>Inputs</h3>
            <ol>
            <li>Go left</li>
            <li>Stop</li>
            <li>Go right</li>
            </ol>
            </description>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyCustomPongWorld.MyInitTask">
            <summary>
            Initialises the game state and loads the resources.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyCustomPongWorld.MyRenderTask">
            <summary>
            Renders the game to visual output. If the GamePauseRequest signal is rised, the game is paused.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GameBoy.MyCustomPongWorld.MyUpdateTask">
            <summary>
            BinaryEvent output has a vector of binary events as follows: "bounce ball", "brick destroyed", "lost life". If the GamePauseRequest signal is rised, the game is paused.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GeneticWorld.MyGeneticTrainingWorld">
             <author>GoodAI</author>
             <meta>JD</meta>
            <status>Working</status>
             <summary><b>Genetic Training World</b>
            
             <p>
             The genetic training world overrides the normal backpropagation training of a neural network group.
             Each timestep, the world executes it's current genetic task. A user defined fitness function evaluates
             the performance of each population member which give each member the score of Fitness when SwitchMember != 0 
             </p> 
            
             <p>
             The fitness function is defined by the user, usually as a C# node. When a member has a score = TargetFitness, the
             genetic task will stop with the weights of that member written to the network. The world that the network is trained against
             needs to be converted into a node by copying the KnownWorlds group up into the nodes group in the conf.xml file.
             </p>
             
             <p><b>I/O:</b>
             <ul>
             <li><b>SwitchMember</b> - If != 0, the genetic task will start testing the next member of the population, recording the current value of the Fitness output block</li>
             <li><b>Fitness</b> - The current fitness of the population member. Recorded when SwitchMember is != 0</li>
             </ul>
             </p>
             
             <p><b>Parmaters:</b>
             <ul>
             <li><b>TrainGenetically</b> - If FALSE, disables all genetic training methods.</li>
             <li><b>PopulationSize</b> - Size of the population to be evolved.</li>
             <li><b>TargetFitness</b> - Target fitness of the populations</li>
             <li><b>Generations</b> - Set a generation limit if the training method supports it. A set limit is > 0</li>
             <li><b>Survivors</b> - Number of survivng population members per generation</li>
             <li><b>MutationRate</b> - Rate of mutation during repopulation.</li>
             </ul>
             </p>
             </summary>
        </member>
        <member name="T:GoodAI.Modules.GeneticWorld.MyGeneticTrainingWorld.Cosyne">
             <author>GoodAI</author>
             <meta>JD</meta>
            <status>Working</status>
             <summary><b>CoSyNE Genetic Training</b>
            
            <p> CoSyNE Training is genetic method for continuous environments which convets the weight matrix of the network using a Discrete
             Cosine Transform (DCT) to a number of significant coefficents, the number of which are defined by the user.
             The rest of the population is filled with chromosomes between <b>Alpha</b> and <b>-Alpha</b> and each
             member converts the DCT back, tests the fitness of the candidate, and if the fitness is >= <b>TargetFitness</b>, the satisfying network is returned. Otherwise
             the CoSyNE recombination, mutation, and permutation methods are employed to create a new population and the
             process starts over.
             </p>
             
             <p>
             Each timestep, a single generation of the CoSyNE method is executed.
             Non reccurent feedforward networks are all that is currently supported. The world will only train the first NN group that it finds at the top
             layer of the overall Network.
             </p>
             
             <p><b>Parmaters:</b>
             <ul>
             <li><b>CoefficientsSaved</b> - The number of coefficeints to be evolved. If equal to the number of weights in the network, the weights are evolved directly without the DCT.</li>
             <li><b>Alpha</b> - Range of the generated coefficients (if evolving coefficients)</li>
             <li><b>WeightMagnitude</b> - Range of the generated weights (if evolving weights directly)</li>
             <li><b>DirectEvolution</b> - Evolve weights without DCT translation? Automatically TRUE if CoefficientsSaved >= number of weights in the NN</li>
             </ul>
             </p>
             </summary>
        </member>
        <member name="T:GoodAI.Modules.Join.MyDistanceNode">
            <author>GoodAI</author>
            <tag>#mm+mp</tag>
            <status> Working </status>
            <summary>
            Takes two vectors and outputs a single number as a measure of their similarity.
            </summary>
            <description>
            To process more vectors at once, use MatrixNode (not all DistanceNode's operations are supported, though).
            </description>
        </member>
        <member name="T:GoodAI.Modules.Join.MyDistanceNode.MyExecuteTask">
            <summary>
            Computes the distance of the input vectors.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Join.DistanceOperation">
            <summary>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Join.MyStackingNode">
            <author>GoodAI</author>
            <tag>#mm+mp</tag>
            <status>Working</status>
            <summary>
            Joins two or more vectors into a single vector.
            </summary>
            <description>
            <ul>
            <li><b>Concatenate:</b> Places each successive input vector after the end of the previous input vector.</li>
            <li><b>Interweave:</b> Interprets input vectors as matrices (based on their ColumnHint) and concatenates the 
                rows of the successive matrices. It concatenates the first rows of the matrices, then it concatenates the 
                second rows of the matrices etc. Input vectors must have the same number of rows.</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Join.MyStackingNode.MyStackInputsTask">
            <summary>
              Performs the desired join operation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Join.MyStackingOperation">
            <summary>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyWorldEngineParams">
            <summary>
            Holds parameters of the game world that are used both by the world and by the engine
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MastermindWorldEngine">
            <summary>
            Holds state and defines the behavior of all objects in the world.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MastermindWorldEngine.ResetHiddenVector">
            <summary>
            called each time the game is reset
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MastermindWorldEngine.Reset">
            <summary>
            Called from InitTask
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MastermindWorldEngine.GetEvaluation(System.Single[],System.Single[],System.Int32@,System.Int32@)">
            <summary>
            Returns the number of bulls (direct hits) and cows (good color, but wrong position) in the guess.
            The vector in guess is compared with the vector in hidden.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MastermindWorldEngine.AddGuess(System.Single[],System.Int32)">
            <summary>
            Adds the newest guess to the history of guesses.
            Adds the evaluation of the newest guess to the history of evaluations.
            </summary>
            <param name="guess">the guess to add</param>
            <param name="oldGuessCount">the number of guesses and evaluations already stored in history.</param>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MastermindWorldEngine.Step">
            <summary>
            // The agent has submitted a guess and confirmed it. Compute next state of the world.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld">
            <author>GoodAI</author>
            <meta>mp</meta>
            <status>Working</status>
            <summary> World for the Mastermind game.</summary>
            <description>
            <p>
            World simulating the <a href="https://en.wikipedia.org/wiki/Mastermind_(board_game)">Mastermind</a> game (aka bulls and cows). <br />
            The game allows the agent to make at most m (typically, m = 12) guesses to find out 
            a hidden vector V of k colours. Typically, k is 4 or 5. A guess is a vector G of k colours. The same colours can repeat in one vector.<br />
            The agent wins if he correctly guesses the vector V (that is, G = V) before he runs out of guesses.<br />
            The world tells the agent how well it made the last guess by outputing the number of bulls B (correctly guessed colors on correct positions)
            and the number of cows W (correctly guessed colors, but on wrong positions) for the last guess.
            After the agent wins or makes m (all available) guesses, the game resets. A new hidden vector V may be set, depending on user input.<br />
            The hidden vector V can be specified as user input. If user input is empty, vector V is random. <br />
            </p>
            
            <p>
            The agent can, at any timestep:
            <ul>
                <li>Output a guess G.</li>
                <li>Confirm the guess G (tell the world that G currently on the ouptut is the guess he wants to make).</li>
            </ul>
            </p>
            
            The world is composed of:
            <ul>
                <li>The agent.</li>
                <li>The set of available colours <b>C</b>.</li>
                <li>The hidden vector <b>V</b> of k colours; <b>V &#8712; C<sup>k</sup></b> .</li>
                <li>The history of <b>n</b> confirmed agent guesses 
                    <b>G<sup>n</sup></b>, <b>G<sub>i</sub> &#8712; C<sup>k</sup></b> &#8704; 0 &#8804; i &#60; n.</li>
                <li>The history of <b>n</b> world's evaluations of confirmed agent guesses 
                    <b>(B,W)<sup>n</sup></b>, <b>(B,W)<sub>i</sub> &#8712; N x N</b> &#8704; 0 &#8804; i &#60; n (number of bulls and cows for each guess).</li>
                <li>A reward signal that is 1 when the agent correctly guesses vector V.</li>
                <!--<li>A reset button (todo).</li>-->
            </ul>
            
            The world resets when:
            <ul>
                <li>The agent makes m guesses.</li>
                <li>The agent correctly guesses hidden vector V.</li>
            </ul>
            
            <h3>Parameters</h3>
            <ul>
                <li><b>Number of available colours:</b> <b>|C|</b>. In other words, number of different colours that can be elements 
                    of vectors V and G. By default, |C|=6.</li>
                <li><b>Length of hidden vector:</b> number <b>k</b> of elements in vector V. By default, k=4.</li>
                <li><b>Number of guesses:</b> number <b>m</b> of guesses the agent can make before the game resets. By default, m=12.</li>
                <li><b>Repeating colors:</b> when true, allows the same color to appear multiple times in the hidden vector.</li>
                <li><b>Hidden vector:</b> the vector that the agent should guess. If empty, a random vector is generated for each game.</li>
                <li><b>Repeatable hidden vector:</b> when true, the random generator is re-set every time the simulation is stopped.
                    This means that the sequence of randomly generated hidden vectors is repeatable.</li>
            </ul>
            
            <h3>Inputs</h3>
            <ul>
                <li><b>GuessInput:</b> vector G of k colors that the agent submits as a guess.</li>
                <li><b>ActionInput:</b> a number (0 or 1) that indicates whether the current guess G is being confirmed by the agent. 
                    This input allows the agent to think multiple computation steps about the correct guess, before providing it to the world.
                    0 means a confirmation of the guess, 1 means the world will ignore the guess.</li>
            </ul>
            
            <h3>Outputs</h3>
            <ul>
                <li><b>HiddenVectorOutput:</b> the hidden vector V of k colours that the agent should find out.</li>
                <li><b>GuessCountOutput:</b> the number of guesses the agent has confirmed since the last world reset.</li>
                <li><b>GuessesOutput:</b> an array of confirmed guesses that the agent has made since the last world reset. 
                    The array has a capacity of <b>m</b> guesses.</li>
                <li><b>GuessEvaluationsOutput:</b> an array of bulls and cows, which the world computed for each agent's confirmed guess. 
                    The array has a capacity of <b>m</b> pairs (bull,cow).</li>
                <li><b>WorldEventOutput:</b> a number that indicates different world events that occur at each time step: 
                    0 = no event, 1 = agent won + reset, -1 = agent lost + reset</li>
                <li><b>VisualOutput:</b> a bitmap that represents the current world state.</li>
            </ul>
            
            </description>
        </member>
        <member name="F:GoodAI.Modules.MastermindWorld.MyMastermindWorld.EVALUATION_ITEM_LENGTH">
            <summary>
            Number of floats needed to store a single evaluation of a guess. 1 for bulls + 1 for cows
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld.ActionInputKind">
            <summary>
            Actions that the agent can submit to the world's ActionInput
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld.EvaluationKind">
            <summary>
            Three relations that an element of a guess can be in w.r.t. the hidden vector
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.UpdateMemoryBlocks">
            <summary>
            Called before the start of the simulation. The sizes of the memory blocks depend on the variables from
            the code region "Parameters".
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.GetGraphicsParameters(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Returns pixel dimensions and distances of important elements on the game board.
            </summary>
            <param name="evaluationSquareWidth">pixel width (and height) of the textures that are used for displaying a bull/cow/miss</param>
            <param name="guessCircleWidth">pixel width (and height) of the texture that is used for displaying a circle of a guess</param>
            <param name="evaluationWidth">total pixel width of the group of bulls/cows/misses</param>
            <param name="evaluationsPerRow">maximum number of bulls/cows/misses that appear on a single line</param>
            <param name="guessWidth">total pixel width of the sequence of circles that forms a guess</param>
            <param name="rowWidth">total pixel width of (a single row of) a game board</param>
            <param name="rowHeight">total pixel height of a single row of a game board</param>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.GenerateGuessColors">
            <summary>
            called from the init task, to create an association between color codes and colors themselves
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.GetGuessColor(System.Int32)">
            <summary>
            Returns the color associated with color code i
            </summary>
            <param name="i">the number whose color we want</param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.LoadBitmap(GoodAI.Modules.MastermindWorld.MyMastermindWorld.TextureType,System.String)">
            <summary>
            Loads a bitmap from a file and stores it in a dictionary. Checks for ARGB color format (e.g. 32bit png). 
            Implementation similar to MyGridWorld.
            </summary>
            <param name="textureType"></param>
            <param name="path"></param>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.GetBitmapSize(GoodAI.Modules.MastermindWorld.MyMastermindWorld.TextureType)">
            <summary>
            Returns the number of floats needed to represent the bitmap in a kernel.
            </summary>
            <param name="textureType"></param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.FillWithChannelsFromBitmap(System.Drawing.Bitmap,System.Single[],System.Int32)">
            <summary>
            Fills the buffer with data from bitmap. The whole image data for R component is first, then G, then B, then A.
            Implementation similar to MyGridWorld.
            </summary>
            <param name="bitmap"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns>The number of floats needed to store bitmap in buffer</returns>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyInitTask">
            <summary>
            Initialize the world (load graphics, create engine).
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyRenderTask">
            <summary>
            Renders the visible area. Not needed for simulation.<br />
            When using an observer to visualize the output, choose RGB as Coloring Method.
            
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyRenderTask.DrawGuessAtPosition(ManagedCuda.CudaStream,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draws a single element of a guess at the provided position
            </summary>
            <param name="s">[async] stream that the kernels will execute in</param>
            <param name="guess">element of a guess to draw</param>
            <param name="position">the positiion (0,1,2,...) of the element inside the guess vector</param>
            <param name="xGroupOffset">X pixel offset of the first element of the guess vector</param>
            <param name="yGroupOffset">Y pixel offset of the first element of the guess vector</param>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyRenderTask.DrawEvaluationAtPosition(ManagedCuda.CudaStream,GoodAI.Modules.MastermindWorld.MyMastermindWorld.EvaluationKind,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Works just like DrawGuessAtPosition, only for evaluations.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyRenderTask.Execute">
            <summary>
            draws mastermind game board into Owner's VisualOutput memory block
            </summary>
        </member>
        <member name="T:GoodAI.Modules.MastermindWorld.MyMastermindWorld.MyUpdateTask">
            <summary>
            Update the world state based on actions, publish the new state.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Observers.MyNeuralNetworkGroupObserver">
            <author>GoodAI</author>
            <meta>hk</meta>
            <status>WIP</status>
            <summary>MyNeuralNetworkGroupObserver</summary>
            <description>
            TO DO:
             <ul>
               <li> Add support for parallel architectures. </li>
               <li> Add input layer. </li>
               <li> It needs update to work with buffers!! I'v some expe with OpenGL but cannot do it in OpenTK, so far... </li>
               <li> needs support for diff networks (LSTM, recur...) and etc.. works just with basic... </li>
             </ul>
            </description>
        </member>
        <member name="F:GoodAI.Modules.Observers.MyArrayOfPointsForNNGroupHelperShape.rnd">
            jsut x,y,z :)
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.MyReplayBuffer">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Replay buffer</summary>
            <description>Replay buffer for creating batches of random samples suitable for batch learning of neural networks.<br />
                I/O:
                    <ul>
                        <li>Sample: Sample to be stored in replay buffer</li>
                        <li>Target: Target associated with the sample to be stored in replay buffer</li>
                        <li>StoreCondition: If condition is connected then replay buffer stores data only if condition[0] > 0. If condition is not connected then replay buffer stores data in each step.</li>
                        <li>SamplesBatch: Batch of samples randomly selected from replay buffer</li>
                        <li>TargetsBatch: Batch of targets associated with the samples batch</li>
                    </ul>
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.MyReplayBuffer.MyCreateBatchTask">
            <summary>Creates a batch containing random samples from replay buffer.<br /></summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyGaussianHiddenLayer">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Development</status>
            <summary>Hidden gaussian layer.</summary>
            <description>
            This is hidden layer but each pair of neurons is interpreted as parameters of Gaussian distribution.
            Parameter 'Neurons' (or N) sets the number of Gaussians where each Gaussian is represented by two neurons.
            Format is like this: input -> {mu_1, sigma_1,..., mu_2*N, sigma_2*N} -> {output_1, ..., output_N}.
            Backprop has regularization term implementing Variational Bayes.
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyNegativeCorrelationEnsembleLayer">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Working</status>
            <summary>Negative Correlation Ensemble Layer.</summary>
            <description>
            Negative Correlation Ensemble Layer takes as input the outputs from multiple output layers (all have to have the same target) and tries to specialize them.
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyOutputOne2OneLayer">
            <author>GoodAI</author>
            <meta>hk</meta>
            <status>Working</status>
            <summary>One-2-One Output layer node.</summary>
            <description>
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyStackLayer">
            <author>GoodAI</author>
            <status>Working</status>
            <summary>
              Node that stacks 2 input nodes and forwards them as one output. It can send deltas back from output to inputs while gradient descent is performed.
            </summary>
            <description>
              A Stack-Layer node should be used as a subnode of the NeuralNetworkGroup.
              It can join 2 nodes together (stack them) and forward them as one node.
              Moreover, while a learning phase of the gradient descent is active and deltas are
              back-prapagated to StackLayer than they are properly distributed to its input nodes.
              Specifically, this is important when we need 2 neural-layers to work in parallel.
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyStackLayer.MyStackBackDeltaTask">
            <summary>
            Sends deltas back
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyStackLayer.MyStackForwardTask">
            <summary>
            Forwards inputs to output
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyAbstractOutputLayer">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>WIP</status>
            <summary>Output layer node.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyConvolutionLayer">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>Convolutional layer.</summary>
            <description>
            Classic convolutional layer that performs convolution on image windows using its filters.\n
            Great tutorial on filter and input dimensions is available here: http://cs231n.github.io/convolutional-networks/ \n \n
            
            You can use AutomaticInput to determine parameters of the convolution. By default, it will try to preserve input dimensions on the output.
            
            
             </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyHiddenLayer">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Hidden layer node.</summary>
            <description>
            This is one of the most commonly used layers within Neural Networks./<br></br>
            It takes an input and feeds another layer, which can be either an output layer or another hidden layer.<br></br>
            The capacity of the network can be scaled by the number of neurons in each layer or by placing multiple layers in succession (deep networks).
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyOutputLayer">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Output layer node.</summary>
            <description>
            The output layer takes a target as input, and automatically scales it's neurons to fit the target.<br></br>
            The cost can be observed or manipulated as an output
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyPoolingLayer">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>Pooling layer.</summary>
            <description>Layer that performs max pooling. It takes max value of each input window and presents it to the output.</description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Layers.MyQLearningLayer">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>QLearning output layer node.</summary>
            <description>
            This node implements QLearning as described on Wikipedia: <a href="https://en.wikipedia.org/wiki/Q-learning"> https://en.wikipedia.org/wiki/Q-learning </a><br></br>
             Number of actions should be set as a parameter<br></br>
            As inputs it takes:<br></br>
             - The current state fed through one or more hidden layers<br></br>
             - Reward for the current state<br></br>
             - The action chosen for the previous state as a vector of actions eg. [0, 0, 1] is the last of 3 actions<br></br>
             The output is the estimated value of each action
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyGaussianForwardTask">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Development</status>
            <summary>
            Tasks for Gaussian hidden layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyGaussianBackDeltaTask">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Development</status>
            <summary>
            Backpropagate the deltas first from Gaussians to parameters (mu, sigma) and then from parameters to input
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyNegativeCorrelationInitTask">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Working</status>
            <summary>
            Initialize Negative Correlation.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyNegativeCorrelationForwardTask">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Working</status>
            <summary>
            Tasks for NegativeCorrelation output layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyNegativeCorrelationBackDeltaTask">
            <author>GoodAI</author>
            <meta>mbr</meta>
            <status>Working</status>
            <summary>
            Backpropagate Negative Correlation.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyFCForwardTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
            Feed forward task for a fully connected layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyFCBackDeltaTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
            Backpropagate the deltas to a fully connected previous layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyFCUpdateWeightsTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
            Updates weights, that are fully connected to the previous layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MySquaredLossTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
            Measures the distance from the target with the commonly used squared loss function.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyCrossEntropyLossTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
                Standard cross-entropy loss function. Use with output layer with softmax activation function.
                Multiclass target vector with '0's and exactly one '1' is expected.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyImageLossTask">
            <author>GoodAI</author>
            <status>Working</status>
            <summary>
                Loss function for comparing two images. 
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyCustomLossTask">
            <meta>kk</meta>
            <status>Working</status>
            <summary>
                To minimise your own loss function set Target to derivatives of the loss function w.r.t. network's output.
                A simple example of custom loss function may be loss(output) = output, which has derivative w.r.t. output equal to 1.
                If you set Target to 1, the network tries to minimise its output. Analogously, setting Target to -1 will attempt to maximise output.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyQLearningTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>This is the main QLearning algorithm, that uses the current timestep as 't+1' and the previous timestep as 't'
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyQLearningBatchTask">
            <summary>Batched Q-Learning. Minibatches must be created from (S_t, S_{t+1}, A_t, R_{t+1}) tuples. 
            <ul>
            <li>S_t is state of the world in current state</li>
            <li>S_{t+1} is the next state</li>
            <li>A_t is the action agent did in S_t</li>
            <li>R_{t+1} is the reward obtained in next state</li>
            </ul> <br />
            Input of the network is then S_now, S_t minibatch and S_{t+1} minibatch stacked together. S_now is current world state.<br />
            BatchSize of NN group has to be set to 2 * X + 1 where X is BatchSize set at ReplayBuffer node.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyInitWeightsTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
                Initialises the layer parameters with chosen parameters.
                It is recommended to use normal distribution with automatic standard deviation (1.0/sqrt(Input.Count)).
            <br></br>
            This gives a high certainty, that the neurons don't start out saturated.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyCreateDropoutMaskTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>
            Creates a dropout mask for the layer according to the Dropout property of the Neural Network Group
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Tasks.MyShareWeightsTask">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>
            First it copies the weights from source layer and then slowly updates them to track source weights according to: <br/>
            new weights = ApproachRate * sourceLayerWeights + (1 - ApproachRate) * weights <br/>
            Set ApproachRate to 1 to use the exact same weights as source layer.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyNeuralNetworkGroup">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Network node group.</summary>
            <description>
            The Neural Network Group is necessary to build a neural network consisting of neural layers.<br></br>
            It is required to control the data flow during feed-forward and backpropagation between layers, as well as holding important hyperparameters and method variables.
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyInitNNGroupTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Initialises Neural Network Group and sets internally used properties.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyIncrementTimeStepTask">
            <author>GoodAI</author>
            <meta>mb</meta>
            <status>Working</status>
            <summary>
            Used only if sequence length (neural group parameter) > 1.
            Increments time step when iterating forth through time.
            Used automatically, keep it checked.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyDecrementTimeStepTask">
            <author>GoodAI</author>
            <meta>mb</meta>
            <status>Working</status>
            <summary>
            Used only if sequence length (neural group parameter) > 1.
            Decrements time step when iterating back through time.
            Used automatically, keep it checked.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyRunTemporalBlocksModeTask">
            <author>GoodAI</author>
            <meta>mb</meta>
            <status>Working</status>
            <summary>
            Used only if sequence length (neural group parameter) > 1. When time step reaches the end of sequence,
            then temporal memory blocks run a mode (method), e.g. sum memory snapshots through time. Default mode is none.
            New modes can be defined in temporal memory blocks source. Used automatically, let it checked.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MySGDTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Stochastic gradient descent is an online training algorithm, that updates each parameter in the direction of the gradient for the current training example.<br></br>
            The gradient used is the partial derivative of each parameter (weight or bias) with respect to the loss function.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyRMSTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>RMSProp is the online adaptation of the Resilient Backpropagation algorithm based on the mean squares of the parameters.<br></br>
            It solves the problem of saturated neurons and vanishing gradients, which can occur with other backpropagation methods.<br></br>
            The mean squares are moving averages based on the smoothing factor, so as to emulate batch learning.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyAdadeltaTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
                Adadelta is an adaptive learning method that changes each weight (parameter) separately and automatically over time.<br></br>
                No manual settings are needed and it is recommended to use the default values which should behave well in all cases.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralNetwork.Group.MyGradientCheckTask">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Gradient checking mainly for developers to make sure the calculated gradients are correct.
            <br></br>
            This should generally be disabled during training, since it will negatively affect performance</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyAbstractFocuser">
             <author>GoodAI</author>
             <meta>df/jk</meta>
            <status>Working</status>
            <summary>Abstract class for crops and resizes input image according to pupil control input.
            Pupil control input must contain position and size of focused area.</summary>
            <description>
             </description>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyUnfocuser">
             <author>GoodAI</author>
             <meta>df/jk-retina</meta>
            <status>Working</status>
            <summary>Crops and resizes input image according to pupil control input.
            Pupil control input must contain position and size of focused area.</summary>
            <description>
            <ul>
              <li>given a lcoation and image it returns patch there</li>
              <li>given a patch and lcoationj it plots patch there</li>
              <li>supports multiple patches at once</li>
              <li>optional retina like format</li>
             </ul>
             </description>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyUnfocuser.MyUnfocusTask">
            <summary>
            given tha patch and location it fit it inot a image, this is similar to canvas.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyUnfocuser.MyRetinaUnfocusTask">
            <summary>
            Given a retina patch and its location, it plots it into a postion.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyFocuser">
             <author>GoodAI</author>
             <meta>df/jk-retina</meta>
            <status>Working</status>
            <summary>Crops and resizes input image according to pupil control input.
            Pupil control input must contain position and size of focused area.</summary>
            <description>
            <ul>
              <li>given a lcoation and image it returns patch there</li>
              <li>supports multiple patches at once</li>
              <li>optional retina-like format (http://papers.nips.cc/paper/4089-learning-to-combine-foveal-glimpses-with-a-third-order-boltzmann-machine.pdf)</li>
             </ul>
             </description>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyFocuser.MyFocuserTask">
            <summary>
            Given the input and [x,y,scale] ([-1,1],[-1,1],[0,1]) the method returns part of the input image that is at that postion.
            <br/>
            If the pupil input is in the form of [N x 3] it returns multiple patches.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyFocuser.MyRetinaTransform">
            <summary>
            Same format as nortmal focuser but returns retina-like result (http://papers.nips.cc/paper/4089-learning-to-combine-foveal-glimpses-with-a-third-order-boltzmann-machine.pdf)
            There is a mask at has high density closer to the center of the interest. Mask is sparse set it points whcih is the size of the output now. Each element of the output corresponds to the average value of pixels that are closest to the postion of that point.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Retina.MyPupilControl">
             <author>GoodAI</author>
             <meta>df</meta>
            <status>Working (K-Means only)</status>
            <summary>Analyzes visual input through growing K-Means clustering.
            Clusters are iterated and current cluster data (position and scale) is sent to the output.</summary>
            <description></description>
        </member>
        <member name="P:GoodAI.Modules.Scripting.IScriptingEngine`1.DefaultKeywords">
            <summary>
            Should return alphabetically ordered space delimited list of keywords for auto complete and syntax highlighting.
            </summary>
        </member>
        <member name="P:GoodAI.Modules.Scripting.IScriptingEngine`1.Language">
            <summary>
            Should return supported language
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Scripting.MyCSharpNode">
            <author>GoodAI</author>
            <status>Working</status>
            <summary>Experimental C# scripting node</summary>
            <description>Node allows user to write C# code directly and run it during simulation. Example code:
            <pre>
            using System;
            using GoodAI.Core.Utils;
            using GoodAI.Core.Nodes;
            using GoodAI.Modules.Scripting;
            
            namespace Runtime
            {
              public class Script
                {
                    public static void Init(MyCSharpNode owner)
                    {
                        MyLog.DEBUG.WriteLine("Init called");
                    }
            
                    public static void Execute(MyCSharpNode owner)
                    {
                        MyLog.DEBUG.WriteLine("Execute called");
            
                        float[] input = owner.GetInput(0).Host;
                        float[] output = owner.GetOutput(0).Host;
            
                        output[0] = 3 * (float)Math.Cos(input[0]);
                    }
                }
            }
            </pre>
            </description>    
        </member>
        <member name="T:GoodAI.Modules.Scripting.MyCSharpNode.MyInitScriptTask">
            <summary>
            Runs Init() method of the script one time
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Scripting.MyCSharpNode.MyExecuteScriptTask">
            <summary>
            Runs Execute() method of the script
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Scripting.MyCSharpNodeGroup.MyInitScriptTask">
            <summary>
            Runs Init() method of the script one time
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Scripting.MyCSharpNodeGroup.MyExecuteScriptTask">
            <summary>
            Runs Execute() method of the script
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Testing.MyKWM2SymbolNode">
            <author>GoodAI</author>
            <meta>mv,mm</meta>
            <status>temporary</status>
            <summary>Converts data from KMeansWM to Symbol rep.</summary>
            <description>
            This is a temporary project-specific node hardly usable for more general purposes and will be removed with a future update.
            Used in the Breakout-playing AI project.
            </description>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.WorldEngineParams">
            <summary>
            Holds parameters of the game world that are used both by the world and by the engine
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrominoRotation">
            <summary>
            Values of the enum constants have meaning, do not change.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisGameBoard">
            <summary>
            Holds the state of the brick area during the game. 
            Updates the state of the brick area after a tetromino lands.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisGameBoard.EraseFullLines">
            <summary>
            Erases filled lines from the game board.
            </summary>
            <returns>number of lines erased</returns>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisGameBoard.MergeTetrominoWithGameBoard(GoodAI.Modules.TetrisWorld.MovingTetromino)">
            <summary>
               Puts the tetromino into the brick area.
               Called when the engine prepares data for structured and visual output of the brick area or when
               a falling tetromino hits the bottom.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisGameBoard.FitTetrominoToGameBoard(GoodAI.Modules.TetrisWorld.BrickType[0:,0:],System.Int32@,System.Int32@)">
            <summary>
            Can move the tetromino to within the horizontal boundaries of the game board (left,right boundaries only). 
            </summary>
            <param name="tetrominoGrid"></param>
            <param name="column">Column in which the left top cell of the descriptive grid is. Top row has index 0.</param>
            <param name="row">Row in which the left top cell of the descriptive grid is. Leftmost column has index 0.</param>
            <returns>Returns false if the tetromino starts to intersect the bottom.</returns>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.MovingTetromino">
            <summary>
            Class that represents the tetromino that is falling down. Specializations of the class define the different 
            tetromino shapes.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.MovingTetromino.TryMovement(GoodAI.Modules.TetrisWorld.BrickType[0:,0:],System.Int32,System.Int32,GoodAI.Modules.TetrisWorld.TetrominoRotation)">
            <summary>
            tries to fit the provided tetromino (represented by its descriptiveGrid) into the game board
            </summary>
            <param name="descriptiveGrid"></param>
            <param name="column"></param>
            <param name="row"></param>
            <param name="rotation"></param>
            <returns>true if the provided tetromino could be fit into the game board</returns>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorldEngine">
            <summary>
            Holds state and defines the behavior of all objects in the world.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorldEngine.Reset">
            <summary>
            Called from InitTask
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorldEngine.Step(GoodAI.Modules.TetrisWorld.TetrisWorld.ActionInputType)">
            <summary>
            Compute next state of the world. Complete game logic for one step.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorldEngine.FillWorldState">
            <summary>
            copies game state to world's memory blocks
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld">
             <author>GoodAI</author>
             <meta>mp</meta>
             <status>Working</status>
             <summary> World for the Tetris game.</summary>
             <description>
             <p>
             World simulating <a href="https://en.wikipedia.org/wiki/Tetris">Tetris</a>. <br />
             The area where tetrominos fall is 10 cells wide and 22 cells high, with the top two cells obscured.<br />
             The tetrominos are spawned randomly at the top. When a row is cleared, all the rows above it are shifted down. <br />
             The score is calculated as &#931;(lines cleared<sub>t</sub>)<sup>2</sup> for all time steps t. <br />
             Every time an n-th row is cleared, the game advances the level. By default, n is 50.
             The levels differ in the speed of the falling tetrominos. <br />
             For each successive level, the tetrominos wait 1 step less before falling down one cell.<br />
             The game is controlled via left, right, rotate left, rotate right and down actions.
             </p>
            
             <p>
             The agent can, at any timestep:
             <ul>
                 <li>Output the action he wants to make. The action can be given to the world either as a vector or
                 as an index into the table of actions, depending on the ActionInputModality parameter.</li>
             </ul>
             </p>
            
             The world is composed of:
             <ul>
                 <li>An area where tetrominos fall.</li>
                 <li>A next tetromino hint.</li>
                 <li>A score counter.</li>
                 <li>A level indication.</li>
             </ul>
            
             The world resets when the agent tops out, i.e. the spawned tetromino overlaps a previously placed tetromino.
            
             <h3>Parameters</h3>
             <ul>
                 <li><b>ClearedLinesPerLevel:</b> number of cleared lines required to increment the game's level (and speed).
                 It is 50 by default.</li>
                 <li><b>AlmostFullLinesAtStart:</b> number of almost full rows that the game begins with.
                 Keeping this parameter non-zero may help the training.</li>
                 <li><b>WaitStepsPerFall:</b> number of timesteps the tetromino waits before moving down by one cell.</li>
             </ul>
            
             <h3>Inputs</h3>
             <ul>
                 <li><b>ActionInput:</b> the action applied upon the falling tetromino in the next time step. The possible actions are:
                 No action (0), Move left (1), Move right (2), Move down (3), Rotate left (4), Rotate right (5).</li>
             </ul>
            
             <h3>Outputs</h3>
             <ul>
                 <li><b>BrickAreaOutput:</b> the area where bricks fall (10x22), with empty cell represented as 0 and the rest with numbers (1-7).</li>
                 <li><b>HintAreaOutput:</b> the area where the next brick is indicated (6x4), together with the indication of the next brick.</li>
                 <li><b>NextBrickNumberOutput:</b> A number (1-7) representing the next brick.</li>
                 <li><b>ScoreOutput:</b> the game's score, as a single number.</li>
                 <li><b>ScoreDeltaOutput:</b> the increase of the game's score from the previous time step, useful as a reward.</li>
                 <li><b>LevelOutput:</b> current level, starting at 0.</li>
                 <li><b>WorldEventOutput:</b> a number that indicates different world events that occur at each time step:
                     0 = no event, 1 = lines were cleared, -1 = game over + reset</li>
                 <li><b>VisualOutput:</b> a bitmap that represents the complete game board.</li>
             </ul>
            
             </description>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld.ActionInputType">
            <summary>
            Actions that the agent can submit to the world's ActionInput
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.GetBrickColor(GoodAI.Modules.TetrisWorld.BrickType)">
            <summary>
            Returns color associated to the specified brick type
            </summary>
            <param name="brick"></param>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld.TextureType">
            <summary>
            Textures used for painting VisualOutput
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.LoadBitmap(GoodAI.Modules.TetrisWorld.TetrisWorld.TextureType,System.String)">
            <summary>
            Loads a bitmap from a file and stores it in a dictionary. Checks for ARGB color format (e.g. 32bit png).
            Implementation same as in MyMastermindWorld (TODO: refactor once TetrisWorld gets moved to BasicNodes).
            </summary>
            <param name="path"></param>
            <param name="textureType"></param>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.GetBitmapSize(GoodAI.Modules.TetrisWorld.TetrisWorld.TextureType)">
            <summary>
            Returns the number of floats needed to represent the bitmap in a kernel.
            Implementation same as in MyMastermindWorld.
            </summary>
            <param name="textureType"></param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.FillWithChannelsFromBitmap(System.Drawing.Bitmap,System.Single[],System.Int32)">
            <summary>
            Fills the buffer with data from bitmap. The whole image data for R component is first, then G, then B, then A.
            Implementation same as in MyMastermindWorld.
            </summary>
            <param name="bitmap"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns>The number of floats needed to store bitmap in buffer</returns>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld.InitTask">
            <summary>
            Initialize the world (load graphics, create engine).
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld.UpdateTask">
            <summary>
            Update the world state based on actions, publish the new state.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TetrisWorld.TetrisWorld.RenderTask">
            <summary>
            Renders the visible area. Not needed for simulation.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.RenderTask.Execute">
            <summary>
            draws tetris game board into Owner's VisualOutput memory block
            data is ready for rendering thanks to updateTask (score, level, brickarea, ...)
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TetrisWorld.TetrisWorld.RenderTask.DrawTextToBitmap(System.String,System.Drawing.Bitmap,System.Int32)">
            <summary>
            Used for drawing "Score", "Level" and "Next" text into the bitmap displayed in VisualOutput.
            </summary>
            <param name="text"></param>
            <param name="bitmap"></param>
            <param name="yOffset"></param>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyAssociativeNetworkWorld">
            <author>GoodAI</author>
            <meta>pd, jv</meta>
            <status>working</status>
            <summary> World outputting concepts and relations loaded from a file or typed in by the user. </summary>
            <description>
            World outputting concepts and relations (as strings encoded into numeric vectors, one letter one value (ASCII value - 32)) loaded from a file or typed in by the user. 
            The information is stored in a comma separated format: <b>A, B, R, p</b> on each line, where <b>A</b> and <b>B</b> are words, <b>R</b> is the relation <b>A->B</b> and <b>p</b> is it's strength. 
            
            <h3>output Memory Blocks</h3>
            <ul>
                <li> <b>Concept1:</b> Concept <b>A</b> coded as a float vector of integer values corresponding to each letter.</li>
                <li> <b>Concept2:</b> Concept <b>B</b> coded as a float vector of integer values corresponding to each letter.</li>
                <li> <b>Relation:</b> Relation <b>R</b> coded as a float vector of integer values corresponding to each letter.</li>
                <li> <b>RealtionStrength:</b> The strength <b>p</b> of the relation <b>R</b> (<b>A->B</b>)</li>
            </ul>
            
            
            <h3>Signals</h3>
            <ul>
                <li> <b>MyDatabaseReadInProgress:</b> signal is raised during first pass of the dataset.</li>
                <li> <b>MyDatabaseReadFinished:</b> signal is raised for one time step, when the first row of the dataset is read for the second time.</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyAssociativeNetworkWorld.MyReadInputTask">
            <summary>
            Reads the whole input file / user text and then outputs the relations one at a time. New relations are outputted every <b>ReadingFrequency</b> ticks.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyStringConversionsClass.StringEncodings">
            <summary>
            Enumeration of different encoding schemes that can be used by text processing nodes
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyStringConversionsClass.PaddingSchemes">
            <summary>
            Different ways to make sure that a word takes up all the space it can
            </summary>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.StringToDigitIndexes(System.Char)">
            <summary>
            Converts char to index in ASCII table. Inverse function to DigitIndexToString().
            </summary>
            <param name="str">Input char.</param>
            <returns>Index of char in ASCII table minus constant 32.</returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.DigitIndexToString(System.Single)">
            <summary>
            Converts an index back to char. Inverse function to StringToDigitIndexes().
            </summary>
            <param name="code"> Index of the character. Should be a whole number. TODO:</param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.StringToUvscCoding(System.Char)">
            <author>GoodAI</author>
            <summary>
            Convert input char from ASCII to Uppercase Vowel-Space-Consonant encoding
            The coding also takes letter similarity and frequency into account
            </summary>
            <meta>vkl</meta>
            <param name="input">Char to convert</param>
            <returns>Encoded character number</returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.UvscCodingToString(System.Single)">
            <author>GoodAI</author>
            <summary>
            Convert input char from Uppercase Vowel-Space-Consonant encoding to ASCII string.
            Inverse of StringToUvscCoding.
            </summary>
            <meta>vkl</meta>
            <param name="input">Char to convert</param>
            <returns>Encoded character number</returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.UvscCodingToDigitIndexes(System.Single)">
            <author>GoodAI</author>
            <summary>
            Converts UVSC coding to digit indexes. TODO: Direct conversion would probably be more efficient
            </summary>
            <meta>vkl</meta>
            <param name="input">Character to convert, in UVSC coding</param>
            <returns>Character in digit index</returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.RepeatWord(System.String,System.Int32)">
            <author>GoodAI</author>
            <summary>
            Takes an input string and returns space-seperated string that 
            repeats the word until TextWidth characters are used
            </summary>
            <meta>vkl</meta>
            <param name="input">String to convert</param>
            <param name="textWidth"></param>
            <returns>Converted string</returns>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyStringConversionsClass.StretchWord(System.String,System.Int32)">
            <author>GoodAI</author>
            <summary>
            Takes an input string and stretches is by repeating letters until it is long enough to fill textWidth.
            </summary>
            <meta>vkl</meta>
            <param name="input">String to convert</param>
            <param name="textWidth">Converted string</param>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyTextInputNode">
            <author>GoodAI</author>
            <meta>pd,vkl</meta>
            <status>working</status>
            <summary> Node for inputing a line of text. </summary>
            <description>
            Converts the input number into a string. If there is no input, converts the user defined Text. Output is encoded as a vector of integers.
            
            <h3>input Memory Blocks</h3>
            <ul>
                <li> <b>InputNumber:</b> Number which should be converted into a float vector of integer values corresponding to each letter. </li>
            </ul>
            <h3>output Memory Blocks</h3>
            <ul>
                <li> <b>Output:</b> The number taken from <b>Input</b> or in the case of no input the text from property variable <b>Text</b> coded as a float vector of integer values corresponding to each letter. It can be optionally transformed to upper case letters. </li>
            </ul>
            
            <h3>Parameters</h3>
            <ul>
                <li> <b>TextWidth:</b> Width of the output (maximum number of characters). If the input is shorter, space characters will be added. If longer, it will be truncated. </li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyTextInputNode.MyOutputTextTask">
            <summary>
            Converts the input number into a string. If there is no input, converts the user defined Text. Output is encoded as a vector of integers.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyTextObserverNode">
            <author>GoodAI</author>
            <meta>pd,os,vkl</meta>
            <status>working</status>
            <summary>
               Node for visualizing vectors as words.
            </summary>
            <description>
            
            The sole purpose of this node is to gather a matrix and visualize each of it's vectors as words (i.e. chains of characters). This visualization is performed via a custom observer - MyVectorTextObserver.
            <h3>Input Memory Blocks</h3>
            <ul>
                <li> <b>Data:</b> Data matrix (M x N) containing one word in each row. In each element is stored one character as an integer depending on the chosen encoding.</li>
                <li> <b>Weights:</b> A vector (of size M) describing importance of each word. The words are written in a descending order according to this weights and the weights also determine the brightness of each word.</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyWriteToFileTask">
            <author>GoodAI</author>
            <meta>Os</meta>
            <status>WIP</status>
            <summary>
            Extracts text from the vector and writes it on File. This task is currently supposed to be used in conjunction with LTM, where each column is a concatenation of one or more vectors, on vectors that represent text.
            The extracted text can be formatted accordingly to represent Concept1,Concept2,Relationship,ConceptStrength,RelationStrength (In such case SplitValue should be 5, value 1 means don't split)
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.LTM.MyVectorTextObserver">
            <author>GoodAI</author>
            <meta>pd,vkl</meta>
            <status>working</status>
            <summary>
               Custom observer for visualizing words - works on MyTextObserverNode.
            </summary>
            <description>
            See MyTextObserverNode for more details.
            </description>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyVectorTextObserver.#ctor">
            <summary>
            /Constructor with node parameter
            </summary>
        </member>
        <member name="M:GoodAI.Modules.LTM.MyVectorTextObserver.Clear">
            <summary>
            Clear screen kernel
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TextProcessing.TextWorld">
            <author>GoodAI</author>
            <meta>mh</meta>
            <status>Working</status>
            <summary>Provides sample or custom text input for additional processing.</summary>
            <description>Provides sample or custom text input for additional processing.</description>
        </member>
        <member name="T:GoodAI.Modules.TextProcessing.TextWorld.MyCUDAGenerateInputTask">
            <summary>Provides sample or custom text input for additional processing.</summary>
        </member>
        <member name="M:GoodAI.Modules.TextProcessing.TextWorld.MyCUDAGenerateInputTask.StringToDigitIndexes(System.Char)">
            <summary>
            Converts char to index in ASCII table.
            </summary>
            <param name="str">Input char.</param>
            <returns>Index of char in ASCII table.</returns>
        </member>
        <member name="T:GoodAI.Modules.Transforms.My2DCropNode">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Crops a 2D image</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.My2DCropNode.MyImageCropTask">
            <description>Performs cropping.</description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAccumulator">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>Temporal operation on input data.</summary>
            <description>Accumulates values according chosen strategy or delays or quantizes input data.<br/><br/>
            <b>How to use it as accumulator:</b> ApproachValue, Geometric, Factor = 1, Target = 0
            </description>    
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAccumulator.MyShiftDataTask">
            <summary>
            Delays data for given number of timesteps (set in node's <b>DelayMemorySize</b> parameter)<br/>
            For initial period it sets given value or uses first value available.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAccumulator.MyApproachValueTask">
            <summary>
            Sums all input values with given decay:
            <ul>
            <li><b>Arithmetic</b> adds/subtracts difference from previous step</li>
            <li><b>Geometric</b> decay is given by chosen factor (value = f * (oldvalue + input - target) + target)</li>
            <li><b>Momentum</b> calculates approximation of moving average (value = input * (1-f) + oldvalue * f)</li>
            </ul> 
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAccumulator.MyQuantizedCopyTask">
            <summary>
            Copies input to output in given period of steps. That value remains on output until next update.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAnalyze2D">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>2D image analyzes.</summary>
            <description>
               Given the input image (2D matrix as memory block), the node is able to apply image processing algorithm. So far, only the optical flow by Lucas and Kanade (1981) is available.
               
            </description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyAnalyze2D.MyOpticalFlowTask">
            <summary>
              Optical flow algorithm tracks all  pixels (or specific features) in an image all the time. The is based on the following observation:
              If there is an object in the image, the difference between corresponding parts (pixels) of the object in two near-by frames should be constant.
              This formulation leads to the set of equations and their solution is solution of the optical flow: <b>the movement of image pixels/features</b>.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyFilter2D">
            <author>GoodAI</author>
            <meta>xx</meta>
            <status>Working</status>
            <summary>Applies selected filter on the 2D input (i.e. an image).</summary>
            <description>
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyFilter2D.MyVariance3x3Task">
            <summary>
            Calculates static measure on the input mem. block on the 3x3 neighborohood of each pixel.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyFilter2D.MyEdgeDetectionTask">
            <summary>
            Simple edge detection algorithm that uses a constrast between each pixel value and the sum of its neighborohood pixels.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyFilter2D.MyGaussianBlurTask">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Gaussian_blur">Gaussian blur</a> method that convolves a 3x3 Gaussian matrix with the input image.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyFilter2D.MySobelEdgeTask">
            <summary>
            Edge detectio nusing the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel filter</a> of size 3x3.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyHash">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Calculates a hash function of input data.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyHash.MyMD5Task">
            <summary>
            Calculates standard MD5 hash.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyRawImageTransform">
            <author>GoodAI</author>
            <meta>mp</meta>
            <status>Working</status>
            <summary>Transforms Raw image input</summary>
            <description>It is meant to be used only with color, Raw 2D images.</description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyRawImageTransform.TransformTarget">
            <summary>
            Conversion options
            </summary>
        </member>
        <member name="F:GoodAI.Modules.Transforms.MyRawImageTransform.TransformTarget.RawBW">
            <summary>
            Raw -> Raw, with color channels reduced to luminance (L, grayscale). 
            The original pixel layout is 32bits = 8bit A, 8bit R, 8bit G, 8bit B. 
            The result pixel layout is 32 bits again, 8bit A, 8 bit L, 8 bit L, 8 bit L
            The correct rendering method to view the results is Raw
            </summary>
        </member>
        <member name="F:GoodAI.Modules.Transforms.MyRawImageTransform.TransformTarget.RGB">
            <summary>
            Raw -> RGB, where color channels are extracted from the pixels and laid out sequentially:
            First Red, then Green, then Blue. A single color value is encoded by one float in range [0,1].
            The result is 3x times as big as the original because of use of floats (and no alpha)
            The correct rendering method to view the results is RGB
            </summary>
        </member>
        <member name="F:GoodAI.Modules.Transforms.MyRawImageTransform.TransformTarget.Grayscale">
            <summary>
            Raw -> Grayscale, similar to RawBW, but with alpha discarded and luminance converted to a float.
            The result pixel layout is 32 bits per pixel again, encoding a single float luminance in range [0,1]
            The correct rendering method to view the results is GrayScale or RedGreenScale
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyRawImageTransform.MyRawImageTransformTask">
            <summary>
            Transforms Raw image to B/W Raw, to RGB, or to Grayscale (RedGreenScale)
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyResize2D">
            <author>GoodAI</author>
            <meta>df,pd</meta>
            <status>Working</status>
            <summary>Resizes input data.</summary>
            <description>
            <h3>It is meant to be used with 2D-data (images).</h3> 
            <b>Exact1toN interpolation type </b> - Input image sizes (both X and Y) must be either divisible or multiples of corresponding resize factors. 
            In another words, to each pixel either in the output image or in the input image must correspond a rectangle of pixels  in the second image. 
            When increasing size, each pixel in the output image has the same value as the corresponding input image, when decreasing size, 
            values of each pixel in the output image are computed as average over all corresponding pixels in the input image. 
            </description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyResize2D.MyImageScaleTask">
            <description>Uses bilinear resampling for perfroming resize.</description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyVectorOpsNode">
            <author>GoodAI</author>
            <meta>mv</meta>
            <status>Working</status>
            <summary>Performs 2D vectors operations. Supports rotation and computing an angle between vectors</summary>
            <description>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyVectorOpsNode.MyRotateTask">
            <summary>
            Rotates 2D vector in first input by number of degrees specified in the first element of the second input
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Transforms.MyVectorOpsNode.MyAngleTask">
            <summary>
            Computes (un)directed angle between two 2D vectors
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyAbstractDiscreteQLearningNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Parent of nodes that use discrete QLearning algorithms.
            </summary>
            <description>
            Parent of nodes that use discrete QLearning memory, which can be observed by the MyQMatrixObserver
            </description>
        </member>
        <member name="T:GoodAI.Modules.Harm.IDecisionSpace">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Each stochastic return predictor has own DS, which contains subset of actions/vars
            of the Root Decision Space
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDecisionSpace.GetCurrentState">
            <summary>
            Read the current state while ignoring non-included variables
            </summary>
            <returns>list of indexes of maxVariables which contains only values of included variables</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDecisionSpace.GetLastExecutedActions">
            <summary>
            Return list of all actions that were just executed including abstract ones, not only those in the DS.
            </summary>
            <returns>List of aciton indexes</returns>
        </member>
        <member name="F:GoodAI.Modules.Harm.MyDecisionSpace.m_S_t">
            <summary>
            Holds vector of indexes of used variables. If the variable is removed, its last
            value should be left in the vector (so that the Q(s,a) matrix coords do not move too much).
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDecisionSpace.GetLastExecutedAction">
            <summary>
            Determine one action that has been just executed. In case that multiple actions are found, 
            the one with the highest level is returned.
            </summary>
            <returns>Index of my action that has been executed, -1 if non of them.</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDecisionSpace.AddAction(System.Int32)">
            <summary>
            Adds action, if the action is abstract, adds also its promoted variable to the DS.
            </summary>
            <param name="index">Index of action to be added.</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDecisionSpace.RemoveAction(System.Int32)">
            <summary>
            The same in the opposite direction; assumed: since the action, which controls this
            variable is not needed, also the variable is not needed.
            </summary>
            <param name="index">Index of action to be removed</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyModuleParams">
            <summary>
            Global config class
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyEligibilityTrace">
            <summary>
            Remembers history of past N steps, learning algorithm computes delta 
            (one-step difference between expected and observed state value) and spreads this
            discounted value back into the history. This speeds up learning significantly.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteQLearning.Learn(System.Single,System.Int32[],System.Int32)">
            <summary>
            Performs Q-Learning (including the Eligibility Trace if enabled).
            </summary>
            <param name="r_t">Reward received as a result of previous action</param>
            <param name="s_tt">Current state s_t'</param>
            <param name="a_t">Previously executed action</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyMotivationBasedDeleteUnselectedASM">
            <summary>
            Sets motivation values of non-selected acitons to the predefined value (e.g. 0).
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyMotivationSource">
            <summary>
            Produces motivation to execute the current strategy (abstract) - action.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyMotivationSource.MakeStep">
            <summary>
            Different dynamics on different levels
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.IHierarchyMaintainer">
            <summary>
            Handles the correct: hierarchical decision-making, learning, hierarchy update
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IHierarchyMaintainer.Learn">
            <summary>
            Each SRP check own reward, executes own learning.
            In the current verison the hierarchical depedencies are ignored (because they can be). 
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IHierarchyMaintainer.InferUtilities">
            <summary>
            Infers utilities of primitive (all in fact) actions from the aciton hierarchy.
            The computed utilities are the final decision of the system.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IHierarchyMaintainer.Subspacing">
            <summary>
            Checks conditions for subspacing, subspaces based on data in the action/variable traces.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IHierarchyMaintainer.ManualSubspacing(System.Int32[],System.Int32[],System.Int32,System.String)">
            <summary>
            Create new abstract action - one StochasticReturnPredictor which promotes one variable.
            Level of the abstraction is detedmined by the actions contained in the action space.
            Note that the level of abstraction is defined by the child ACTIONS here!
            </summary>
            <param name="variables">list of variables to place in the DS</param>
            <param name="actions">list of actions to the DS</param>
            <param name="promotedVariable">variable that is promoted by this SRP</param>
            <param name="label">name of this "action"</param>
            <returns>newly created abstract action</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.IVariableHistory.AddVariable(System.Int32)">
            <summary>
            Add a variable to the history
            </summary>
            <param name="index">index of the variable in the RootDecisionSpace</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.IVariableHistory.AddAllPotentialVariables">
            <summary>
            Remembers values of all added variables in time (or all possible variables discovered in the future)
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyLocalVariableHistory">
            <summary>
            The same as a VariableHistory, but each SRP has its own.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyLocalVariableHistory.monitorVariableChanges(GoodAI.Modules.Harm.MyStochasticReturnPredictor)">
            <summary>
            This updates the variable weights in the DS, if the weight is under the threshold, 
            the corresponding variable should be removed from the DS.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyLocalVariableHistory.performOnlineVariableRemoving(GoodAI.Modules.Harm.MyStochasticReturnPredictor)">
            <summary>
            This should be called only after receiving the reward. 
            Frequency of variable changes relative to rewards received.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyVariableHistory.GetVariableChangedBefore(System.Int32)">
            <summary>
            Looks n steps into the history, checks for THE FIRST monitored variable that has changed.
            </summary>
            <param name="steps">number steps in the past</param>
            <returns>first identified variable that changed its value</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyVariableHistory.GetVariablesChangedBefore(System.Int32)">
            <summary>
            Return list of monitored variables that changed given no. of steps in the hsitory
            </summary>
            <param name="steps">number steps in the past (0 excluded)</param>
            <returns>list of all variable indexes that changed that time step</returns>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Implements HARM based on the discrete Q-Learning algorithm.
            </summary>
            <description>
            HARM - Hierarchy, Abstraction, Rinforcements, Motivations. 
            A system, that is able to autonomously identify own capabilities and tries to learn them (in a MDP environments).
            The system:
            
             <ul> 
               <li> Senses environment (vector of data: variables and constants) </li>
               <li> Acts in the environment (produces actions)</li>
               <li> Observes consequences of own actions. If some variable changes, the agent asumes that it is a consequence of its action and tries to learn this new ability:</li>
                <ul>
                <li> It creates new Stochastic Return Predictor (SRP) = decision space + discrete RL algorithm + source of motivation to execute this behavior</li>
                <li> This new SRP has a goal to learn how to change this variable. It is done by making connection link from variable change to reward of this SRP</li>
                <li> The decision space of this SRP should contain only subset of environment variables</li>
                <li> From now on, the SRP tries to learn how to change the variable by observing actions taken by the agent and receiving own reward</li>
                <li> All SRPs vote by publishing utilities of child actions in a given state.</li>
                <li> Utilities produced by the SRP are scaled by the amount of motivation. Motivation increases in time and is set to 0 when the reward is received.</li>
               </ul>
             </ul> 
            
            The node publishes utilities of primitive actions in a given state. 
            The utility of action is computed as a sum of utilities (scaled by motivations) from all parent SRPs. 
            Therefore all SRPs learn in parallel and resulting strategy followed by the agent is a result of all intentions of the agent.
            <br>
            Current version uses one level of hierarchy of RL decision spaces based on interaction 
            with the environment.
            </br>
            <h3>Before use:</h3>
             <ul> 
                <li> Works well in environments which fulfill the MDP (Markov Decision Process) environments.</li>
                <li> Works only for positive integer values of variables. Need to rescale input values by the RescaleVariables parameter. </li>
                <li> Currently uses one level of hierarchy of SRPs.</li>
                <li> Variable and action subspacing should be used carefully with respect to the environment, or disabled for slower, but safer learning.</li>
             </ul> 
            </description>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteHarmNode.ReadTwoDimensions(System.Single[0:,0:]@,System.Int32[0:,0:]@,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Method creates 2D array of max action utilities and max action labels over across selected dimensions.
            The values in the memory are automatically scaled into the interval 0,1. Realtime values are multiplied by motivations.
            </summary>
            <param name="values">array passed by reference for storing utilities of best action</param>
            <param name="labelIndexes">array of the same size for best action indexes</param>
            <param name="XVarIndex">global index of state variable in the VariableManager</param>
            <param name="YVarIndex">the same: y axis</param>
            <param name="showRealtimeUtilities">show current utilities (scaled by the current motivation)</param>
            <param name="policyNumber">optinal parameter. In case that the agent has more strategies, you can choose which one to read from.</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyVariableUpdateTask">
            <summary>
            Monitors which variables should be contained in the decision space.
            
            For each dimension of GlobalDataInput checks if there were multiple values, 
            if yes, it is identified as a variable and added into the DS.
            
            Also, inputs are rescaled by the value of RescaleVariables.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyActionUpdateTask">
            <summary>
            Number of primitive actions is predefined, abastract acitons are created here.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyHierarchicalLearningTask">
             <summary>
             Implements Q-learning in multiple separate SRPs.
            
             <h3>Parameters</h3>
             <ul>
                 <li><b>Alpha: </b>Learning factor - the higher the faster the learning is.</li>
                 <li><b>Gamma: </b>How far into the future algorithm looks for learning.</li>
                 <li><b>RewardScale: </b>Increases the value of reward stored (helps increasing accuracy).</li>
                 <li><b>Lambda: </b>How strongly are past values updated (bigger values increase the learning speed, but can cause learning oscilations).</li>
                 <li><b>EligibilityTraceEnabled: </b>Use the trace?</li>
                 <li><b>EligibilityTraceLen: </b>How many past steps to update at once (determined efectively by the lambda parameter).</li>
             </ul>
             </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyHierarchyCreationTask">
            <summary>
            Implements subspacing (on a global level), variable/action removing/addding.
            
            <h3>Parameters</h3>
            <ul>
                <li><b>ActionTraceLength: </b>Length of trace meory for actinos.</li>
                <li><b>VariableTraceLength: </b>Length of trace meory for variables.</li>
                <li><b>ActionSubspacingThreshold: </b>The lower the threshold, the less actions will be in the Decision Space.</li>
                <li><b>VariableSubspacingThreshold: </b>The lower the threshold, the less variables will be in the Decision Space.</li>
                <li><b>HistoryForgettingRate: </b>How to weight the importance of actions/variables in the past.</li>
                <li><b>SubspaceActions: </b>Subspace actions, or use all actions in new Decision Space.</li>
                <li><b>SubspaceVariables: </b>Subspace variables? If disabled, all sensory data are considered in all decision spaces.</li>
                <li><b>OnlineSubspaceVariables: </b>Subspace variables online? If some variable does not change often enough (relatively to receving reward) can be removed from the DS..</li>
                <li><b>OnlineHistoryForgettingRate: </b>If variable changes 1 is added to its value. All values are decayed each step by the OnlineHistoryForgettingRate.</li>
                <li><b>OnlineVariableRemovingThreshold: </b>After receiving the reward, the all variables in the DS are checked how often they changed in the history. If the value is under this threshold, variable will be removed from the DS.</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyHierarchicalActionSelection">
            <summary>
            Infers utility values of primitive actions from the RL hierarchy. Publishes utilities.
            
            <h3>Parameters</h3>
            <ul>
                <li><b>MotivationChange: </b>How much to increase the motivation each step if no reward is received.</li>
                <li><b>UseHierarchicalASM: </b>Eeach SRP publishes utilities of all actions or should use own Action Selection Method (ASM) (select only one action)?</li>
                <li><b>MinEpsilon: </b>If the UseHierarchicalASM is enabled, this is minimum probability of randomization in the ASM.</li>
                <li><b>PropagateUtilitiesInHierarchy: </b>If disabled, utility does not propagete from SRPs to child actions.</li>
            </ul>
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyHierarchicalActionSelection.Execute">
            <summary>
            Infer utility values of primitive actions from the hierarchy and publish.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyPostSimulationStepTask">
            <summary>
            Mandatory task, cleans-up data after each step.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyMotivationOverrideTask">
            <summary>
            Monitors manual motivation inputs. 
            Overrides all inner motivations for actions if the threshold on the input MotivationsOverride is above 0.5.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyActionUtilsVisualization">
            <summary>
            Only a placeholder for Observer methods and it does need to be enabled.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyActionUtilsVisualization.GetSRPForVar(System.Int32)">
            <summary>
            If the variable can be controlled by own SRP, return it.
            </summary>
            <param name="ind">Global index of variable</param>
            <returns>SRP that controls the state of this variable</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyActionUtilsVisualization.ReadTwoDimensions(System.Single[0:,0:]@,System.Int32[0:,0:]@,GoodAI.Modules.Harm.MyStochasticReturnPredictor,System.Int32,System.Int32,System.Boolean)">
            <summary>
            For a given predictor, the method creates 2D array of max action utilities and max action labels over selected dimensions.
            The values in the memory are automatically scaled into the interval 0,1. Realtime values are multililed by motivations (therfore are bigger).
            </summary>
            <param name="values">array passed by reference for storing utilities of best action</param>
            <param name="labelIndexes">array of the same size for best action indexes</param>
            <param name="predictor">an asbtract action</param>
            <param name="XVarIndex">global index of state variable in the VariableManager</param>
            <param name="YVarIndex">the same: y axis</param>
            <param name="showRealtimeUtilities">show current utilities (scaled by motivations from the source and the hierarchy?)</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteHarmNode.MyActionUtilsVisualization.ReadSize(GoodAI.Modules.Harm.IDecisionSpace,GoodAI.Modules.Harm.MyVariable,System.Int32,System.String)">
            <summary>
            Size is given by the no of variables , but only in case that the variable is contained in the ds.  
            </summary>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyRootDecisionSpace">
            <summary>
            Holds all known actions and variables.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyAction.AddPromotedVariable(System.Int32,GoodAI.Modules.Harm.MyRootDecisionSpace)">
            <summary>
            Works with only one variable
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyAction.SetJustExecuted(System.Boolean)">
            <summary>
            Primitive actions are updated on the bottom, abstract aciton sets this by itself.
            </summary>
            <param name="yes">Whether the action (or child action) has just been executed.</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyAction.JustExecuted">
            <summary>
            This indicates that the action has been executed in the current step. 
            It is used in the higher levels of hierarchy: higher level action "hides" execution
            of lower level actions that are part of its decision space (policy). 
            </summary>
            <returns>True if the action (or some acton from my decuison sapce) has jsut been executed.</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyAction.GetMyTotalMotivation">
            <summary>
            TotalUtility is composed of sum of utilities promoted from parents and my Motivation (0 here).
            </summary>
            <returns>Total utility of the action (motivation*RS + utils.from parents)</returns>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyMotivatedAction">
            <summary>
            Action, that has own source of motivation with own inner dynamics.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.ActionManager">
            <summary>
            Stores all aciton that the agent is capable of (primitive and abstract ones).
            New actions are added online, the old ones are disabled in the particular spaces.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.VariableManager">
            <summary>
            Stores all variables that agent have seen so far (list is updated from the
            input data).
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.VariableManager.GetCurrentState">
            <summary>
            Decode the current state based on all known variables and their current values.
            </summary>
            <returns>List of indexes (only states) to be used in the Q(s,a) memory.</returns>
        </member>
        <member name="T:GoodAI.Modules.Harm.IStochasticReturnPredictor">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            SRP is a standalone system, which includes: decision space, learning algorithm, action selection.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IStochasticReturnPredictor.Learn">
            <summary>
            Update the Q(s,a) memory
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IStochasticReturnPredictor.SelectAction">
            <summary>
            Compute Utilities, Select action (changes utility values), scale utilities, propagate them to childs.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IStochasticReturnPredictor.PostSimulationStep">
            <summary>
            Should be called after the simulation step.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IStochasticReturnPredictor.GetMaxMemoryValue">
            <summary>
            for scaling memory values to the interval 0,1
            </summary>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.IStochasticReturnPredictor.AddNewVariable(System.Int32)">
            <summary>
            If new variable is detected in the DS, it should be added into all decision spaces,
            knowledge then can be shared from the old memory. 
            
            Then the strategy is updated for nev values by learning. 
            If both strategies (old and new one) are "the same", the variable can be then removed.
            </summary>
            <param name="no">index of new variale</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyStochasticReturnPredictor">
            <summary>
            Is an abstract action, which lears in own decision space to get own type of reward.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyStochasticReturnPredictor.PerformActionAdding(System.Collections.Generic.List{System.Int32})">
            <summary>
            This adds all primitive actions, that were just executed. 
            Note that multilevel hierarchy is built by variable adding in the current version.
            </summary>
            <param name="actionsJustExecuted">lsit of actions that were just executed</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.IDimList">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Implements multidimensional matrix as recursive list of lists of depth = no. dimensions.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDetectChangesNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>
            Computes direction of change of the input variables (independently). 
            </summary>
            <description>
            The value on the output is given by parameter OutputScale and is zero/positive/negative. Used for producing rewards to the DiscreteQLearningNode.
            </description>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDetectChangesNode.MyDifferenceDetector">
            <summary>
            Detect difference compared to previous input and publish it.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteQLearningNode">
             <author>GoodAI</author>
             <meta>jv</meta>
             <status>Working</status>
             <summary>
             Implements Q-Learning (Q-Lambda) algorithm based on matrix representation of data.
             </summary>
             <description>
             Node does the following:
                <ul>
                <li> <b>Reveives data:</b> Accepts world state description and currently selected action (code 1ofN).</li>
                <li> <b>Learns:</b> Updates own Q(s,a) matix.</li>
                <li> <b>Publishes what it has learned: </b>Publishes utilities of actions in the current state, these are scaled by the value of motivation.</li>
               </ul>
            
             Note that input data have to be rescaled to integer values.  
             No. of matrix dimensions and dimension sizes adapts itself to the size of data seen so far 
             (that is no. of variables and no. of values of each variable).
             
             <h3>Inputs</h3>
             <ul>
                 <li> <b>GlobalData:</b> Vector describing state of the environment (can contain variables and constants). Values are scaled by the InputRescaleSize parameter.</li>
                 <li> <b>SelectedAction:</b> Vector of size [numberOfActions]. The highest value indicates action that has been executed by the agent.</li>
                 <li> <b>Reward:</b> If the value is non-zero, the RL receives the reward.</li>
                 <li> <b>Motivation:</b> Scales action utilities: the higher the motivation, higher values on the output.</li>
             </ul>
             <h3>Output</h3>
             <ul>
                 <li> <b>Utilities:</b> Vector of action utilities in a given state (the higher the value, the better to use the action).</li>
             </ul>
             <h3>Memory Blocks</h3>
             <ul>
                 <li> <b>RewardStats:</b> Two values that indicate {Total Reward/Step, Total Reward}, where Total Reward is sum of all rewards received during the simulation.</li>
             </ul>
             <h3>Parameters</h3>
             <ul>
                 <li> <b>InputRescaleSize:</b> Memory is indexed by integers, user should ideally rescale variable values to fit into integers.</li>
                 <li> <b>Number of Primitive Actions:</b> Number of primitive actions produced by the agent (e.g. 6 for the current gridworld, 9 for the tictactoe game).</li>
                 <li> <b>SumRewards:</b> Sum across the values in the vector of rewards?</li>
             </ul>
             
             </description>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteQLearningNode.ReadTwoDimensions(System.Single[0:,0:]@,System.Int32[0:,0:]@,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Method creates 2D array of max action utilities and max action labels over across selected dimensions.
            The values in the memory are automatically scaled into the interval 0,1. Realtime values are multiplied by motivations.
            </summary>
            <param name="values">array passed by reference for storing utilities of best action</param>
            <param name="labelIndexes">array of the same size for best action indexes</param>
            <param name="XVarIndex">global index of state variable in the VariableManager</param>
            <param name="YVarIndex">the same: y axis</param>
            <param name="showRealtimeUtilities">show current utilities (scaled by the current motivation)</param>
            <param name="policyNumber">not used here, this RL learns only one policy</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteQLearningNode.MyVariableUpdateTask">
            <summary>
             <ul>
               <li>  Checks which variables should be contained in the decision space.</li>
               <li>  For each dimension of GlobalDataInput checks if there were multiple values, 
            if yes, it is identified as a variable and added into the DS. </li>
               <li>  Also, inputs are rescaled by the value of RescaleVariables.</li>
              </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteQLearningNode.MyLearnTask">
            <summary>
            Updates the values of the Q(s,a) matrix by means of Q-Learning with eligibility trace.
            
            <h3>Parameters</h3>
            <ul>
                <li><b>Alpha:</b> Learning factor - the higher the faster the learning is.</li>
                <li><b>Gamma:</b> How far into the future algorithm looks for learning.</li>
                <li><b>RewardScale:</b> Increases the value of reward stored (helps increasing accuracy).</li>
                <li><b>Lambda:</b> How strongly are past values updated (bigger values increase the learning speed, but can cause learning oscilations).</li>
                <li><b>EligibilityTraceEnabled:</b> Use the thrace?</li>
                <li><b>EligibilityTraceLen:</b> How many past steps to update at once (determined efectively by the lambda parameter).</li>
            </ul>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteQLearningNode.MyReadUtilsTask">
            <summary>
            Reads utility values in the current state, rescales them by the MotivationInput and publishes to the UtilityOutput.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyDiscreteQLearningNode.MyActionUtilsVisualization">
            <summary>
            Updates the <b>RewardStats</b> values = {Total Reward/Step, Total Reward}.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.MyDiscreteQLearningNode.MyActionUtilsVisualization.ReadTwoDimensions(System.Single[0:,0:]@,System.Int32[0:,0:]@,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Method creates 2D array of max action utilities and max action labels over across selected dimensions.
            The values in the memory are automatically scaled into the interval 0,1. Realtime values are multiplied by motivations.
            </summary>
            <param name="values">array passed by reference for storing utilities of best action</param>
            <param name="labelIndexes">array of the same size for best action indexes</param>
            <param name="XVarIndex">global index of state variable in the VariableManager</param>
            <param name="YVarIndex">the same: y axis</param>
            <param name="showRealtimeUtilities">show current utilities (scaled by the current motivation)</param>
        </member>
        <member name="T:GoodAI.Modules.Harm.MyActionSelectionNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>Implements motivation-based action selection method. Motivation weights between greedy and random strategy.</summary>
            <description>
            
            <ul>
                <li> Uses epsilon-greedy action seleciton for selecting action based on utility values on inputs.</li>
                <li> Epsilon defines amount of randomization in the greedy strategy and is altered by the motivation input: the higher motivation -> the less randomization (more greedy strategy).</li>
                <li> Selected action is published in 1ofN code.</li>
            </ul>
            
            <h3>Inputs</h3>
            <ul>
            <li><b>Utilities: </b>Vector of utility values corresponding to particular actions (e.g. produced by the DiscreteQLearningNode).</li>
            <li><b>Motivation: </b>Current amount of motivation to use the learned strategy (weights exploitation vs. exploration of the strategy).</li>
            </ul>
            <h3>Outputs</h3>
            <ul>
            <li><b>SelectedAction: </b>Action that was selected, coded in 1ofN code (e.g. to be received by the DiscreteQLearningNode(s)).</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Harm.MySimpleSortTask">
            <summary>
            Choose the best action according to the probability of M, otherwise completely random.
            
            If there are multiple identical highest values, choose randomly from all.
            
            <h3>Parameters</h3>
            <ul>
            <li><b>Selection Period: </b>Select new action each N steps</li>
            <li><b>Min Epsilon: </b>Minimum probability of randomization (in case that Motivation=1)</li>
            <li><b>Random From All: </b>If multiple maximum utilities found, choose randomly from all actions? If false, choses randomly from the best actions.</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Harm.IDiscreteQSAMemory">
            <summary>
            Defines the implementation of memory with adaptable dimensions and dimension sizes. 
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDiscreteQSAMemory.WriteData(System.Int32[],System.Int32,System.Single)">
            <summary>
            Place the utility of action into the memory, memory allocated if needed.
            </summary>
            <param name="stateValues">Array of indexes definind the current state</param>
            <param name="action">Current action to be written in the state</param>
            <param name="value">Utility value of the action</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDiscreteQSAMemory.DisableDimension(System.Int32)">
            <summary>
            Set the dim. list sizes to 0 in the simplest case. This indicates that the dimension is not used.
            
            Possible improvement1: recursivelly deallocate the memory
            Possible improvement2: average all utilities accross the deleted dimension (knowledge reuse).
            </summary>
            <param name="no">index of dimension to be deleted</param>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDiscreteQSAMemory.ReadData(System.Int32[])">
            <summary>
            Read utility values in a given state. 
            If there is no data for action, the default values are returned.
            </summary>
            <param name="states">Array of indexes describing the curren state</param>
            <returns>Array of aciton utilities, for each of currently used (and non-disabled) actions one value</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDiscreteQSAMemory.GetDimensionSizes">
            <summary>
            Get list of sizes of particular dimensions (the last one is (max) no. of actions)
            </summary>
            <returns>List of dimension sizes</returns>
        </member>
        <member name="M:GoodAI.Modules.Harm.IDiscreteQSAMemory.GetMaxStateVariables">
            <summary>
            Array of indexes used for indexing the matrix is finite -> also the max no. of state variables.
            </summary>
            <returns>Returns max number of state variables</returns>
        </member>
        <member name="T:GoodAI.Modules.LSTM.MyLSTMLayer">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Long Short Term Memory layer</summary>
            <description>Fully recurrent Long Short Term Memory (LSTM) hidden layer with forget gates and peephole connections trained by truncated Real-Time Recurrent Learning (RTRL) algorithm.<br />
                         Parameters:
                         <ul>
                            <li>InputActivationFunction: Activation function applied to cell input</li>
                            <li>GateActivationFunction: Activation function applied to gate input. Read-only, all gates use sigmoid activation function</li>
                            <li>ActivationFunction: Activation function applied to cell output. 
                            Read-only, NO_ACTIVATION is used because after multiplication by output gate's activation, no more activation function is applied.</li>
                            <li>LearningTasks: Either RTRL (Real-time recurrent learning) or BPTT (Back-propagation through time). 
                            <ul>
                            <li><b>RTRL</b> is able to adapt to any sequence length. It sometimes suffers from an exponential explosion of the values of its
                            inner cell states. This negatively affects the outputs of the LSTM node. To avoid the explosion, set the CLIP_CELL_STATE value
                            of the RTRL's Feed forward task to a value around 1. For your convenience, there is also a similar parameter CLIP_GRADIENT in
                            Update weights task.</li>
                            <li><b>BPTT</b> expects a predefined sequence length. It requires that the neural group's parameter
                            <b>Temporal/SequenceLength</b> be set to the length of the sequence that should be learned. BPTT uses temporal memory blocks. 
                            Because of that, BPTT requires that the task
                            "Transform Input" be enabled and that neural group node's RunTemporalBlocksMode, IncrementTimeStep and DecrementTimeStep tasks be enabled.<br />
                            Note that when you use BPTT, some memory block observers provide meaningful data only when their Temporal/TimeStep parameter is set to -1.
                            </li>
                            </ul>
                            </li>
                            <li>CellsPerBlock: Number of cells in each LSTM memory block</li>
                            <li>MemoryBlocks: Number of LSTM memory blocks in the layer</li>
                            <li>Neurons: Read-only number of cells in the layer calculated as MemoryBlocks * CellsPerBlock</li>
                         </ul>
                         
                         Signals:
                         <ul>
                            <li>Reset: Resets LSTM's internal state to initial value</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.LSTM.MyLSTMLayer.MyTransformInputToTemporalTask">
            <summary>Transform input memory block to a Temporal memory block <br />
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LSTM.Tasks.MyLSTMDeltaTask">
            <summary>Computes deltas of output gates and cell state errors.</summary>
        </member>
        <member name="T:GoodAI.Modules.LSTM.Tasks.MyLSTMUpdateWeightsTask">
            <summary>Updates all network weights according to gradient. <br />
            Parameters:
            <ul>
                <li>CLIP_GRADIENT: Limits error gradient into [-CLIP_GRADIENT,CLIP_GRADIENT] interval. Set to 0 for no bounds</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LSTM.Tasks.MyLSTMFeedForwardTask">
            <summary>Performs forward pass in the layer. <br />
            Parameters:
            <ul>
                <li>CLIP_CELL_STATE: Limits cell states into [-CLIP_CELL_STATE,CLIP_CELL_STATE] interval. Set to 0 for no bounds</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.LSTM.Tasks.MyLSTMInitLayerTask">
            <summary>Initialises layer with random weights.</summary>
        </member>
        <member name="T:GoodAI.Modules.LSTM.Tasks.MyLSTMPartialDerivativesTask">
            <summary>Computes truncated RTRL partial derivatives.</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyPIDController">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>PID Controller</summary>
            <description>Proportional-Integral-Derivative (PID) controller.
            Minimises error between measured process variable (Input) and its setpoint (Goal) by adjusting manipulated variable (Output).
            PID controls single process variable by single manipulated variable. When trying to control more variables, PID controllers for each variable are independent.<br />
                I/O:
                    <ul>
                        <li>Input: Measured process variable</li>
                        <li>Goal: Desired setpoint of process variable</li>
                        <li>Output: Controller output of manipulated variable</li>
                    </ul>
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyPIDController.MyInitTask">
            <summary>Initialises node.</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyPIDController.MyControlTask">
            <summary>PID control to minimise error (Input - Goal) calculted as weighted sum of proportional, integral, and derivative terms.<br />
                     Parameters:
                         <ul>
                            <li>PROPORTIONAL_GAIN: Weight of gain proportional to current error</li>
                            <li>INTEGRAL_GAIN: Weight of gain from sum of all past errors</li>
                            <li>DERIVATIVE_GAIN: Weight of gain from derivative of current error</li>
                            <li>INTEGRAL_DECAY: Error integral multiplier (Integral[t] = CurrentError[t] + INTEGRAL_DECAY * Integral[t - 1])</li>
                            <li>OFFSET: Offset to be added to controller output</li>
                            <li>MIN_OUTPUT: Lower bound of controller output</li>
                            <li>MAX_OUTPUT: Upper bound of controller output</li>
                        </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyJacobianTransposeControl">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Computes set of torques that emulate effect of a virtual force applied to a point on body</summary>
            <description>Inverse kinematics method that uses transpose of Jacobian matrix to calculate joint torques that emulate effect of a virtual force applied to a point of a body in 3D coordinates<br />
            I/O:
                         <ul>
                            <li>Anchors: Positions of joint anchors in a 3xN matrix, where each row contains X, Y, and Z coordinates for corresponding joint</li>
                            <li>RotationAxes: 3xN matrix where each row is a 3D unit vector pointing along the direction of current axis of rotation for corresponding joint</li>
                            <li>Point: X, Y, and Z coordintes of end effector where the force is to be applied</li>
                            <li>Force: Virtual force 3D vector</li>
                            <li>Output: Joint torques</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyJacobianTransposeControl.MyJacobianTransposeTask">
            <summary>Jacobian transpose method</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DPendulumWorld">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Inverted pendulum in 3D World based on BEPUphysics engine.</summary>
            <description>Inverted pendulum with one or two controlled joints with one or three degrees of freedom. <br />
            Parameters:
                         <ul>
                            <li>MOTOR_MODE: Behaviour of joint motor control, VelocityMotor sets target velocity of rotation, ServoMotor sets target rotation</li>
                            <li>ELBOW_FIXED: If true, the second joint (elbow) becomes fixed in its position and uncontrollable</li>
                            <li>POLE_DOF: Degrees of freedom of the uncontrolled joint on the bottom of pole</li>
                            <li>GRAVITY: Gravity strength</li>
                         </ul>
            I/O:
                         <ul>
                            <li>Controls: Control signals for the joints</li>
                            <li>SpherePush: Optional, adds the 3D vector to sphere's velocity</li>
                            <li>Joints: Rotation of the joints, may not be accurate</li>
                            <li>PoleRotation: 1 or 3 dimensional rotation of pole depending on POLE_DOF setting</li>
                            <li>ControlsCopy: Copy of previous control signals</li>
                            <li>SpherePosition: 3D position of the sphere</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DPendulumWorld.My3DWorldTask">
            <summary>Simulates the 3D world</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DManipulatorWorld">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>Manipulator in 3D World based on BEPUphysics engine</summary>
            <description>Manipulator from BEPUphysics demo "Robotic Arm Thingamajig" with 5 rotational joints. <br />
            I/O:
                         <ul>
                            <li>Controls: Control signals for the joints</li>
                            <li>Joints: Rotation of the joints, may not be accurate</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DManipulatorWorld.My3DWorldTask">
            <summary>Simulates the 3D world</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DBipedalRobotWorld">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Bipedal robot in 3D world based on BEPUphysics engine.</summary>
            <description>Bipedal robot with 9 controlled joints. <br />
            Parameters:
                         <ul>
                            <li>MOTOR_MODE: Behaviour of joint motor control: VELOCITY_MOTOR sets target velocity of rotation; SERVO sets target rotation; MUSCLE_PAIR requires two controls per joint, for flexor and extensor force</li>
                            <li>MOTOR_MAX_FORCE: Maximu force  motor can produce, doesn't apply for MUSCLE_PAIR motor mode</li>
                            <li>JOINT_STIFFNESS: Stiffnes coefficient of spring in the joint</li>
                            <li>GROUND: Toggle ground for robot to stand on</li>
                            <li>GRAVITY: Gravity strength</li>
                            <li>*_WEIGHT: Weight of the respective body part</li>
                            <li>*_WIDTH or *_HEIGHT: Dimension of the respective body part</li>
                            <li>FORCE_MULTIPLIER: Applies only to MUSCLE_PAIR motor mode, coefficient for flexor/extensor strength</li>
                            <li>VELOCITY_MULTIPLIER: Applies only to MUSCLE_PAIR motor mode, coefficient for flexor/extensor target velocities</li>
                         </ul>
            I/O:
                         <ul>
                            <li>Controls: Control signals for the joints</li>
                            <li>Push: Optional, adds the 3D vector to torso's velocity</li>
                            <li>Joints: Rotation of the joints, may not be accurate</li>
                            <li>TorsoRotation: Rotation of torso in 3D coordinates</li>
                            <li>FeetPressure: Approximate pressure applied to rear part of left foot, front part of left foot, rear part of right foot, front part of right foot in that order</li>
                            <li>ControlsCopy: Copy of previous control signals</li>
                            <li>CenterOfMass: Position of center of mass in 3D coordinates</li>
                            <li>ContactPoint: Position of center of pressure in 3D coordinates</li>
                            <li>JointPosition: 3xN matrix of positions of all joints, each row containing a 3D position of respective joint</li>
                            <li>JointAxis: 3xN matrix of axis of joint rotation, each row containing a 3D axis of respective joint</li>
                            <li>TorsoPosition: Position of torso in 3D coordinates</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DBipedalRobotWorld.My3DWorldTask">
            <summary>Simulates the 3D world</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.My3DWorld">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>3D World based on BEPUphysics engine.
            It can simulate various constraint systems defined via XML.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyArmWorld">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>World simulating robotic arm</summary>
            <description> Simulation of a robotic arm in 2D environment. <br />
            Parameters:
                         <ul>
                            <li>JOINTS: Number of arm's joints, length of arm parts is automatically determined by golden ratio</li>
                            <li>WORLD_WIDTH: Width of the visualised world</li>
                            <li>WORLD_HEIGHT: Height of the visualised world</li>
                         </ul>
            I/O:
                         <ul>
                            <li>MusclesInput: Torque to be applied by muscles on each joint, positive values rotate clockwise</li>
                            <li>ResetInput: Optional, values other than zero reset arm to starting configuration</li>
                            <li>VirtualMusclesLengthInput: Optional, visualises passed muscles lengths in VirtualOutput without affectng the "real" arm</li>
                            <li>HighlightPointInput: Optional, expects 2D position of a point to be highlighted in visual output</li>
                            <li>VisualOutput: Visualisation of the arm in 2D world</li>
                            <li>MusclesLengthOutput: Length of muscles pulling clockwise, from minimum of 0 to maximum of 1</li>
                            <li>JointsPositionOutput: 2D position of all joints</li>
                            <li>EndPosition: 2D position of end effector</li>
                            <li>VirtualOutput: Visualisation of virtual arm</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyArmWorld.MyArmTask">
            <summary>Simulates the arm<br />
            Parameters:
                         <ul>
                            <li>DRAW: If set to true, end effector draws in the environment</li>
                            <li>UPDATE_VISUAL_OUTPUT: If set to false, visual output is not updated</li>
                            <li>GRAVITY_FORCE: Gravity force</li>
                            <li>MUSCLE_FORCE: Maximum muscle force</li>
                            <li>FRICTION: Friction</li>
                            <li>HIGHLIGHT_X: X coordinate of a point highlighted in environment</li>
                            <li>HIGHLIGHT_Y: Y coordinate of a point highlighted in environment</li>
                         </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyRecurrentNetwork">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Recurrent network trained by Real-Time Recurrent Learning</summary>
            <description>Simple recurrent network with fully recurrent hidden layer trained by Real-Time Recurrent Learning (RTRL) algorithm. <br />
                         Parameters:
                         <ul>
                            <li>INPUT_UNITS: Read-only number of units in input layer</li>
                            <li>HIDDEN_UNITS: Number of units in hidden layer</li>
                            <li>OUTPUT_UNITS: Read-only number of units in output layer</li>
                         </ul>
                         
                         I/O:
                         <ul>
                            <li>Input: Input vector copied to activation of input layer units and propagated through the network</li>
                            <li>Target: Desired activation of output layer units </li>
                            <li>Output: Activation of output layer units </li>
                         </ul>
                         
                         Signals:
                         <ul>
                            <li>Reset: Resets activation of all network units to zero</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyRecurrentNetwork.MyInitNetworkTask">
            <summary>Initializes network with random weights.</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyRecurrentNetwork.MyFeedforwardTask">
            <summary>Performs forward pass in te network.</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MyRecurrentNetwork.MyRTRLTask">
            <summary>Computes RTRL partial derivatives and updates network weights.</summary>
        </member>
        <member name="T:GoodAI.Modules.Motor.MySequenceRecorderNode">
            <author>GoodAI</author>
            <meta>kk</meta>
            <status>Working</status>
            <summary>Records sequence of input vectors into a matrix</summary>
            <description>Records sequence of predefined number of recent Inputs and stores them in Output as a matrix. Most recent input vector is in first row of the matrix.<br />
                         Parameters:
                         <ul>
                            <li>LENGTH: Length of the sequence to record, also number of rows in the output matrix</li>
                         </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Motor.MySequenceRecorderNode.MyRecordTask">
            <summary>Records the sequence</summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.MyRBMGroup">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
                Restricted Boltzmann Machine node group.
            </summary>
            <description>
                Node group used for Restricted Boltzmann Machines and deep learning.
                Derived from Neural Network group whose functionality it inherits.
                Can be used for initialization of weights prior to using SGD.
            </description>
        </member>
        <member name="T:GoodAI.Modules.RBM.MyRBMInputLayer">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
                Input layer of Restricted Boltzmann Machine network.
                Can only act as a visible layer. In an RBM network, there is only one input layer and it is its first node.
            </summary>
            <description>
            Index of this layer is (or rather must be) 0.
            
            There must be precisely one input layer in an RBM group.
            </description>
        </member>
        <member name="M:GoodAI.Modules.RBM.MyRBMInputLayer.RBMRandomActivation">
            <summary>
            Randomly activates the output neurons.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.MyRBMLayer">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
                One layer of Restricted Boltzmann Machine network.
                Inherited from classic neural hidden layer.
                Can act as both visible and hidden layer.
            </summary>
            <description>
            <p>Specify the layer to be learned with CurrentLayerIndex parameter.</p>
            <p>Layers are indexed from 0 (zero).</p>
            <br/>
            
            <p>Current layer 0 means we are learning weights between the 0th and 1st layers (i. e. the first two layers).</p>
            <p>Typically, you want to learn the RBM layer-wise starting from 0.</p>
            <p>Start with layer index of 0, after first weights (between 0 and 1) are learned, increase it to 1, etc., until you reach (last but one)th layer.</p>
            <br/>
            <p>Use RBMFilterObserver (upper right by default) to see weights.</p>
            </description>
        </member>
        <member name="M:GoodAI.Modules.RBM.MyRBMLayer.RBMRandomActivation">
            <summary>
            Randomly activates the output neurons.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.Tasks.MyRBMInitLayerTask">
            <summary>
            Initializes RBM Layer memory/parameters with zeroes where needed.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.Tasks.MyRBMRandomWeightsTask">
            <summary>
            Randomly initalizes the weights of the RBM network using normal distribution and specified standard deviation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.MyRBMLearningTask">
            <summary>
                Learning of the whole RBM group.
            <p>
            Specify the layer to be learned with CurrentLayerIndex parameter.
            Layers are indexed from 0 (zero).
            </p>
            <p>
            Current layer 0 means we are learning weights between the 0th and 1st layers (i. e. the first two layers).
            Typically, you want to learn the RBM layer-wise starting from 0.
            Start with layer index of 0, after first weights (between 0 and 1 are learned), increase it to 1, etc., until you reach (last but one)th layer.
            </p>
            <p>
            Use RBMFilterObserver (upper right by default) to see weights.
            </p>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.RBM.MyRBMReconstructionTask">
            <summary>
            <p>
            Reconstruction task for RBM.
            </p>
            <p>
            Layers are indexed from 0 (zero).
            </p>
            
            Can reconstruct from
            <ul>
                <li> input up to the layer specified by CurrentLayerIndex.</li>
                <li> layer specified by CurrentLayerIndex back towards the first (input) (0th) layer.</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.SparseCoding.MyScalarToSDRNode">
            <author>GoodAI</author>
            <meta>js</meta>
            <status>Working</status>
            <summary>Encodes/Decodes scalar values into/from Sparse Distributed Representation
            with the required properties</summary>
            <description>n-tuple of scalar float values is encoded into [n x LENGTH] binary matrix, where each
            row corresponds to its respective scalar value.
            The input scalar values have to be inside the interval [MIN, MAX], otherwise they are cropped
            to this interval (lower value than MIN is set to MIN, larger value than MAX is set to MAX).
            Parameters:<br />
            <ul>
            <li>MIN: minimal value of a scalar value in the input vector</li>
            <li>MAX: maximal value of a scalar value in the input vector</li>
            <li>LENGTH: length of the binary vector that encodes one scalar value (length of one output row in case of vector input)</li>
            <li>ON_BITS_LENGTH: the number of bits equal to 1 (e.g. 2% of the LENGTH value for the CLA algorithm)</li>
            <li>RESOLUTION: read-only parameter calculated as (MAX - MIN) / (LENGTH - ON_BITS_LENGTH)
            - the smallest quantization step of input value that is preserved by the encoding</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.SparseCoding.MyScalarToSDRNode.MyEncodeTask">
            <summary>Encodes n-tuple of scalar values into [n x LENGTH] binary matrix, where each
            row corresponds to its respective scalar value. In the row, the continuous block of
            ON_BITS_LENGTH on bits (=1.0) is placed in the row between the beginning of the row (representing the MIN value)
            and the end of the row (representing the MAX value) on a position scaled by the Input float value.
            The rest of the values in the output row is equal to zero.
            The input scalar values have to be inside the interval [MIN, MAX], otherwise they are cropped
            to this interval (lower value than MIN is set to MIN, larger value than MAX is set to MAX)
            and the ON_BITS_LENGTH value has to be smaller than LENGTH.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.SparseCoding.MyScalarToSDRNode.MyDecodeTask">
            <summary>Decodes the most probable float value from every row of the input encodings.
            The input vectors can contain float values betveen 0 and 1, the decoding algorithm
            uses sliding window of the length ON_BITS_LENGTH to find in each row a position of a continuous
            sequence of on bits with the largest total sum. Column of float values representing these
            positions is then given as a decoded output.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Clustering.MyKMeansNode">
            <author>Radoslav Bielek</author>
            <status>WIP</status>
            <summary>Not finished version of the K-means algorithm</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.IWorldEngine">
            <summary>
            Defines the behavior of all objects in the world.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.GridWorld.SimpleGridWorldEngine.PrintNames(System.Boolean)">
            <summary>
            Prints names of output data.
            </summary>
            <param name="useConstants">Print names of global Data, or only variables?</param>
            <returns>String containing all names separated by spaces</returns>
        </member>
        <member name="M:GoodAI.Modules.GridWorld.SimpleGridWorldEngine.GetGlobalOutputVarNames">
            <summary>
            Return vector of variable names (corresponds to the GlobalVariable data output)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.GridWorld.SimpleGridWorldEngine.GetGlobalOutputDataNames">
            <summary>
            Return vector of all data names (corresponds to the GlobalData data output), includes also all constants
            </summary>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyMapH">
            <summary>
            definitions of custom maps here
            </summary>
            
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyMapJ">
            <summary>
            definitions of custom maps here
            </summary>
            
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyMapL">
            <summary>
            definitions of custom maps here
            </summary>
            
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyMapK">
            <summary>
            definitions of custom maps here
            </summary>
            
        </member>
        <member name="T:GoodAI.Modules.GridWorld.Tale">
            <summary>
            end of custom map definitions
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyGridWorld">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>A simple discrete simulator with maze and controllable objects.</summary>
            <description>
            
            A discrete world with one agent, the agent can:
            <ul>
                <li>Do nothiong (action 0)</li>
                <li>Move in 4 directions (actions 1,2,3,4)</li>
                <li>and control controllable objects (action 5).</li>
            </ul>
            
            The world is composed of:
            <ul>
                <li>an agent</li>
                <li>free tales</li>
                <li>obstacles</li>
                <li>two types of static objects: controllable (door switch, lights switch) and controlled objects (door, lights)</li>
            </ul>
            
            
            
            <h3>Outputs</h3>
            <ul>
                <li> <b>Global:</b> publishes all information about the world, that is:
            agent's position and (changeable) properties of all objects with their positions.</li>
                <li> <b>Variables:</b> publishes only all variables in the world (typically omits positions
            of static objects), for testing purposes.</li>
            <li> <b>AgentPosX:</b> Agent's current position on the X axis.</li>
            <li> <b>AgentPosY:</b> Agent's current position on the Y axis.</li>
            <li> <b>Visual:</b> bitmap representing the current world state.</li>
            <li> <b>EgocentricVisual:</b> egocentric view of the agent with predefined size</li>
            <li> <b>MapSizeOutput:</b> publishes the following vector of information about wolrd size: [maxX, maxY, 1/maxX, 1/maxY].</li>
            </ul>
            
            
            <h3>Inputs</h3>
            <ul>
                <li> <b>Action:</b> Vector indicating the selected action. The index of maximum value is evaluated as a selected action. 
                Actions are in the following order: NOOP,LEFT,RIGHT,UP,DOWN,PRESS.</li>
            </ul>
            
            <h3>Parameters</h3>
            <ul>
                <li><b>ShowInEgocentricView: </b>show the agent in egocentric view?</li>
                <li><b>EgocentricViewLimit: </b>size of the egocentric visual</li>
                <li><b>WorldBoundsValue: </b>used for boundaries in the egocentric view</li>
                <li><b>USED_MAP: </b>chooses one of predefined maps</li>
                <li><b>TEXTURE: </b>different textures for the visual representation</li>
            </ul>
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyGridWorld.MyInitTask">
            <summary>
            Initialize the world (load graphics etc.).
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyGridWorld.MyRenderTask">
            <summary>
            Renders the visible area, not needed for simulation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyGridWorld.MyUpdateTask">
            <summary>
            Update the world state based on actions, read the new state and publish it.
            
            <description>
            <h3>Parameters</h3>
            <ul>
                <li><b>ForceDoorSwitches: </b>forces the state of door switches in a selected position / agent cannot change it</li>
                <li><b>ForceDoorSwitchesState: </b>defines state of all door switches in the game, if ForceDoorSwitches is enabled</li>
                <li><b>ForceLightSwitches: </b>forces the state of light switches in a selected position / agent cannot change it</li>
                <li><b>ForceLightSwitchesState: </b>defines state of all light switches in the game, if ForceLightSwitches is enabled</li>
                <li><b>LimitFieldOfView: </b>if enabled, only those values of World's output are updated, which correspond to objects that are in the agent's visible area</li>
                <li><b>DoorsAlwaysPassable: </b>if enabled , the agent is always able to go through the door</li>
                <li><b>ContinuousMovement: </b>if enabled , the agent moves in a continuous way</li>
            </ul>
            </description>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.GridWorld.MyGridWorld.MyResetAgentTask">
            <summary>
            Resets the agent position in the world to the specified [x,y] coordinates.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixCPUOps">
            <summary>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyDataDistNode">
            <author> Honza Knopp</author>
            <status> Under dev., only a few of basic functions so far...</status>
               
            <summary>
            </summary>
            <description>
            <h2> TODO: </h2>
               User input (i.e. A+B*3-5)
            </description>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixAutoOps">
             <summary>
             Class for performing matrix operations
             </summary>
             
             <h2> Usage </h2>
               MyMatrixAutoOps mat_operation;
             
               //--- in init task
               mat_operation = new MyMatrixAutoOps(Owner, Matrix.MatOperation.Multiplication | Matrix.MatOperation.Addition, A); // It may need A for setting up kernel size!  Operation is for 
            
             
              //--- when you need to use it
              mat_operation.Run(Matrix.MatOperation.Multiplication, A, B, Output1);
              mat_operation.Run(Matrix.MatOperation.Multiplication, A, 10.4f, Output2);
              mat_operation.Run(Matrix.MatOperation.Addition, A, B, Output3);
            
        </member>
        <member name="M:GoodAI.Modules.Matrix.MyMatrixAutoOps.Run(GoodAI.Modules.Matrix.MatOperation,GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Int32)">
            <summary>
            Enables overriding the dimensions to be applicable on tensors. Result columnHint seems not to be used for any operation so there is no need to override it.
            </summary>
            <param name="operation"></param>
            <param name="A"></param>
            <param name="Result"></param>
            <param name="AColumnHint">sees A as a matrix with this number of columns</param>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixCublasOps">
            <summary>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixKernelOps">
            <summary>
               Perform operations that are defined by kernel
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Matrix.MyMatrixKernelOps.Run(GoodAI.Modules.Matrix.MatOperation,GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Int32)">
            <summary>
            Enables overriding the dimensions to be applicable on tensors
            </summary>
            <param name="operation"></param>
            <param name="A"></param>
            <param name="Result"></param>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MatOperation">
            <summary>
            Operations that are allowed to run using the Matrix Node
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixOps">
            <summary>
            Strategy DesignPatern:
               This is the abstract class that defines what will happen, then specific instance (that depends on the execuion=operation type (CPU/GPU/cublas..)) will execute the queried operation
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixNode">
            <author>GoodAI</author>
            <meta>jk</meta>
            <status> Working </status>
            <summary>
              This performs several operations like addition, multiplication etc.
            </summary>
            <description>
            
            <h3> Features: </h3>
            <ul>
             <li> Allows multiplication addition with different input sizes, so instead of only A*B (where A,B are matrices), it supports A*v (v is vector), v*A or even const*A. </li>
             <li> For several opts (getRow, const*A), two input types are supported: 1) memory block from another node; 2) number in "ExecuteParams/DataInput".</li>
             <li> This is just a node layer above the MatrixAutoOps class, so you can use it simple in your code too.</li>
            </ul>
            
            <h3> Usage of operations: </h3>
            <ul>
             <li><b>Addition,Multiplication,Substraction,MultiplElemntWise </b> (two memBlock inputs, or one into A and set the DataInput0 paramter): Two inputs (each of them can be matrix, or vector, or constat). Be careful about the coorect sizes/dimensions of the inputs, it does column/row-wise operation. If only input to the A, then it perforsm multuiplication with the value at DataInput.</li>
             <li><b>DotProd </b> (two memBlock inputs): performs trans(vec) * vec. be carful about the size and dimensions.</li>
             <li><b>MinIndex, MaxIndex </b> (one mem block input): returns min/max index in the vector of its Absolute values.</li>
             <li><b>GetCol,GetRow </b> (two memBlock inputs, or one into A and set the DataInput0 paramter): returns n-th column of the input. N can be DataInput0 or value in the memory block in the B-input.</li>
             <li><b>Minus </b> (one memBlock input): returns -A</li>
             <li><b>Normalize </b> (one memBlock input): return normalized matrix A, Norm2 used in this case.</li>
             <li><b>Norm2 </b> (one memBlock input): returns norm2 of the matrix A</li>
             <li><b>Exp, Abs, Log, Round, Floor, Ceil </b> (one memBlock input): returns Exp/Log/Abs/Floor/Round/Ceil of each element of the matrix A as a new matrix.</li>
            <ul>
            <h3> Parmaters</h3>
            </ul>
              <li> <b>Behaviour/Operation:</b> Matrix operation. </li>
              <li> <b>Execute/DataInput0:</b> If one value should be inserted directly, the par. has usage in Multipl, Additon, GetRow... </li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.Matrix.MyMatrixNode.MyExecuteTask">
            <summary>
            parameter ,,Execute/params/DataInput0'' can be used for some operations when second input is not given. For example Addition, Multiplication, GetRow, GetCol...
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyGrowingNeuralGasNode">
            <author>GoodAI</author>
            <meta>rb</meta>
            <status>Working</status>
            <summary>Growing neural gas implementation with various growing mechanisms</summary>
            <description>
            Parameters:<br />
            <ul>
            <li>MAX_CELLS: maximum possible number of active neural gas cells</li>
            <li>INIT_LIVE_CELLS: the initiali active cell of neural gas</li>
            <li>INPUT_SIZE: size of the input vector, also the length of neural gas vector, set automatically, read only</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyInitGrowingNeuralGasNodeTask">
            <summary>
            Initialization of the growing neural gas node
            Parameters:
            <ul>
            <li>MIN_INIT_INPUT: minimal value of the input and reference vector cell</li>
            <li>MAX_INIT_INPUT: maximal value of the input and reference vector cell</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyFindWinnersTask">
            <summary>
            Find the neural gas cell with best matching reference vector to the input
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyAdaptWinningFractionTask">
            <summary>
            For GNG with consciousness modification it is needed to store the winning fraction of each neuron cell.<br />
            B_PARAM: learning rate of the winning fraction counter (the counter is based on the Hebbian learning rule)
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyBiasTermTask">
            <summary>
            For GNG with consciousness modification this task compute biased winning neuron cell
            C_FACTOR: the strength of consciousness, if set to zero the algorithm is standard GNG
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyFindConsciousWinnersTask">
            <summary>
            Find the winner with considering the consciousness bias
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MySendDataToOutputTask">
            <summary>
            Send all the neccessary data to the corresponding output fields
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyAddLocalErrorAndUtilityTask">
            <summary>
            For the winning neural cell cummulate its error and the utility value
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyCreateConnecionTask">
            <summary>
            Create connection between the winner 1 and 2 (if there isn't one already)
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyAdaptRefVectorTask">
            <summary>
            Adapt the reference vector of the winner and its connected neural cell<br/>
            The adaptation can be set in a way that not trained cells (distinquished by the low winning count) are adapting faster than trained ones.
            Parameters:
            <ul>
            <li>E_b_YOUNG: the learning rate for the untrained winner cell</li>
            <li>E_b_OLD: the learning rate for the trained winner cell</li>
            <li>E_n_YOUNG: the learning rate for the untrained neighboring cell</li>
            <li>E_n_OLD: the learning rate for the trained neighboring cell</li>
            <li>DECAY_FACTOR: the decay factor of the learning rate, the learning rate changes exponentialy from _YOUNG to _OLD value</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyIncrementConnectionAgeTask">
            <summary>
            Increment the connection age emanating from the winner neuron cell
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyRemoveConnsAndCellsTask">
            <summary>
            Remove the connections if they are old and cells if they don't have any connections or if they are not utilized<br/>
            Note: the neural cell removing according to utility factor was not really efficient and hard to set
            Parameters:<br/>
            <ul>
            <li>MAX_AGE: maximum possible age for the connection, if it is higher the connection is removed</li>
            <li>USE_UTILITY: if True - use the removing based on cell utility, if False - don't use it</li>
            <li>UTILITY: the utility threshold for removing the cells</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyAddNewNodeTask">
            <summary>
            Adding new nodes (neural cells) to the neural gas<br/>
            Rules:<br/>
            <ul>
            <li>INCREMENTAL: the new node is added each fixed number of steps in the place between node with the highest accumulated error and its neighbor with highest accumulated error</li>
            <li>VECTOR_OUTLIER: if the input is too far from the closest cell the new one is created with the reference vector same as the input</li>
            <li>EQUILIBRIUM: the new node is added every time when the average accumulated error reach a pre-defined value</li>
            </ul>
            Incremental:<br/>
            <ul>
            <li>LAMBDA - number of time steps when the new cell is added</li>
            <li>ALFA - fraction of the error which is subtracted from the neighbors of newly created neural cell</li>
            </ul>
            Vector outliers:<br/>
            <ul>
            <li>DISTANCE - the distance percentage between winner 1 and 2 which, if reached new neural cell is created on the place of input vector</li>
            </ul>
            Equilibrium:<br/>
            <ul>
            <li>AVG_E_TH - average error threshold, if reached new cell is created on the place as in Incremental adding rule</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.NeuralGas.MyDecreaseErrorAndUtilityTask">
            <summary>
            Decrease accumulated error of each cell by the factor BETA
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToePlayerNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>Node that plays the Tic Tac Toe game in MyTicTacToeWorld.</summary>
            <description>
            
            Connect to the state output and corresponding input, this node will play the TicTacToe.
            Choose whether it plays with X or O before the simulation (has to correpsond with the World input).
            
            The node uses combination of simple rules with heuristic-based minimax algorithm searching 4 moves ahead.
            
            The node should be used in the ConditionalGroup, which is triggered by the PlayerX/O signal.
            
            <h3>Outputs:</h3>
            <ul>
                <li> <b>ActionOutput:</b>OneOfN code specifying the position where to place the X/Y.</li>
            </ul>
            
            <h3>Inputs</h3>
            <ul>
                <li> <b>StateInput:</b>9 numbers that have values: {0 (empty), 1 (O), 2 (X)}</li>
            </ul>
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToePlayerNode.MyPlayerTask">
            <summary>
            TicTacToe player.
            
            <h3>Parameters</h3>
            <ul>
                <li> <b>StateInput:</b>How well the computer plays. 1=good, 0=completely random.</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToeWorld">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>Simulator of Tic Tac Toe game.</summary>
            <description>
            
            World for playing the TicTacToe game. The world has common output defining state of the game. 
            For each player there is a separate output with events (reward=won, punishment=lost, incorrect_move=place already taken) and input for actions (max value is taken).  
            
            <h3>Outputs:</h3>
            <ul>
                <li> <b>State:</b> Vector of length 9 with values {0,1,2} = {EMPTY, PLAYER_O, PLAYER_X}.</li>
                <li> <b>EventO:</b> Vector of events for the PLAYER_O formatted as follows {REWARD, PUNISHMENT, INCORRECT_MOVE}.</li>
                <li> <b>EventX:</b> Vector of events for the PLAYER_X formatted as follows {REWARD, PUNISHMENT, INCORRECT_MOVE}.</li>
                <li> <b>Visual:</b> Bitmap representing the current game state.</li>
            </ul>
            
            <h3>Inputs</h3>
            <ul>
                <li> <b>PlayerXAction:</b> Vector of size 9 which chosen action. Action = place, where to put the X (maximum value is taken as an action). If X is already taken, the step is missed and the player has another attempt.</li>
                <li> <b>PlayerYAction:</b> Vector of size 9 which chosen action. Input is processed only if the corresponding signal is Raised.</li>
            </ul>
            
            The world sends two signals which are supposed trigger players in conditional groups.
            </description>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToeWorld.MyInitTask">
            <summary>
            Initialize the world (load graphics etc.).
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToeWorld.MyRenderTask">
            <summary>
            Renders the visible area, not needed for simulation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.MyTicTacToeWorld.MyMultiPlayerTask">
            <summary>
            Read action of a given player. If the aciton is incorrect, sets the event and the same player has another attempt.
            
            If the action is valid, signal for another player is raised.
            
            If some of players won, the corresponding events are set and game ends (after both players have seen the event).
            
            <description>
            <h3>Parameters</h3>
            <ul>
                <li><b>Player O Starts: </b>Whether the Player_O should start.</li>
                <li><b>Randomize who starts: </b>Randomize who has the first move?</li>
            </ul>
            </description>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.TicTacToe.ITicTacToeEngine">
            <summary>
            Thing, which plays the tic tac toe
            </summary>
        </member>
        <member name="M:GoodAI.Modules.TicTacToe.MyEngineA.CanWinByMoving(System.Int32[],GoodAI.Modules.TicTacToe.MyTicTacToeWorld.PLAYERS)">
            <summary>
            If a given player can immediately win by moving an a particular place
            </summary>
            <param name="currentState">state of the board</param>
            <param name="who">player who can win</param>
            <returns>-1 if cannot win in one move, corrspoding board position otherwise</returns>
        </member>
        <member name="M:GoodAI.Modules.TicTacToe.MyEngineA.EvalSet(System.Int32[],System.Int32[],GoodAI.Modules.TicTacToe.MyTicTacToeWorld.PLAYERS)">
            <summary>
            returns the value of a given game state for given player
            </summary>
            <param name="state">game state to be evaluated</param>
            <param name="indexes">list of 3 indexes (row, column, diagonal)</param>
            <param name="player">COMPUTER or PLAYERS</param>
            <returns>value of the state</returns>
        </member>
        <member name="T:GoodAI.Modules.Vision.MaskCreationNode">
            <author>GoodAI</author>
            <meta>jk</meta>
            <status>Working</status>
            <summary>
            ?
            </summary>
            <description> ? </description>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyJoinPatches">
            <author>GoodAI</author>
            <meta>jk</meta>
            <status> Working </status>
            <summary>
              Concatenate patches/segments into objects.
            </summary>
            <description>
            The node requires a set of patches/superpixels (each defined with its location x,y) as input and joins them into a groups.
            Within the every group, there have to exists a path from one input segment (S1) to the another one (S2) such that
            distance between each ngh. nodes on one way between S1 and S2 is smaller then the treshold.
            
              <h4> Inputs:</h4>
               <ul>
                <li>Patches: [nx3]   matrix of x,y,scale of n patches/superpixels/objects.</li>
                <li>Desc:    [nxdim] descriptor of each path/superpixel/objects.</li>
                <li>Mask:    [axb]   image where each pixels value corresponds to the segment id of the pixel.</li>
               </ul>
               
              <h4> Outputs:</h4>
               Same like input, but segmetns are concatenated. As the size of the output's Patches and Desc is smaller, undefined elements are with -1.
               
            
            
              <h4> Parameters </h4>
              <ul>
                <li> ThresholdDescSim:  Required similarity between vicinity descriptors within a group.</li>
              </ul>
            
              <h4>Observer:</h4>
               When the observer is used to visualize the result, you can change Operation/ObserverMode to change what is shows:
              <ul>
               <li> Mask. </li>
               <li> Mask overlay with the graph.</li>
               <li> Graph with highlighted weights. </li>
               <li> Mask with ids. </li>
              </ul>
             
            </description>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyJoinPatches.MyProcessImPatchBasTask">
            <summary>
            Execute joining patches into groups of objects.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyKMeansWM">
             <author>GoodAI</author>
             <meta>jk,mv</meta>
             <status> Working</status>
             <summary>
                On-the-fly clustering of incoming data. The node expects descriptor of the patch and its position. Then, it assigned cluster id to the input and change the clusters.
             </summary>
             <description>
                Clustering based on the position and desc of the element.
                
               <h4> Inputs:</h4>
                <ul>
                 <li>ObjectDesc:  [1xdim]   Descriptor.</li>
                 <li>ObjectXY:    [1x3]     XYS.</li>
                 <li>WorldEvent:  [1]       Information such game over is used in that input.</li>
                 <li>Image:       [N]       Image, used only for the visualization.</li>
                </ul>
                
               <h4> Outputs:</h4>
                 <ul>
                 <li>NOfObjects:     [1]                 number of objects/clusters in the dbse.</li>
                 <li>ClusCenters:    [MaxClusters x dim] descriptors of each cluster.</li>
                 <li>ClusCentersXY:  [MaxClusters x 3]   XYS positions of each cluster.</li>
                </ul>
                
             
             <h4>Paramters</h4>
              <ul> 
                <li> MaxClusters: Maximum number of elements in the memory. </li>
                <li> ThresholdDescSim: Inverse distance that is necessary to assign input data into the existing memory element.</li>
                <li> UpdateClusterCentersOrdering: Will I update database?</li>
                <li> WeightXY: how to prefer XY similarity vs. descriptor similarity.</li>
                <li> MoveClusCenterValue: Value to update cluster center, it is previous + c*newElemen</li>
               </ul>
               
            
               <h4> Observer:</h4>
                 It shows positions of clusters in the XY plane. If the the Image input is used, it overlays it on the image.
                
             </description>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyKMeansWM.MyKMeansWMInitTask">
            <summary>
            
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyKMeansWM.MyKMeansWMExecuteTask">
            <summary>
             Process input data
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Vision.MyKMeansWM.MyKMeansWMExecuteTask.NormalizeVector(GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="Vec">input vector</param>
            <param name="dim">dimetiosn of the vec</param>
            <param name="id_start">vec start dispalcement</param>
        </member>
        <member name="T:GoodAI.Modules.Vision.MyKMeansWM.MyKMeansWMReSortOutputTask">
            <summary>
            In each iteration step, resort databse as FILO. So, the element that just arrived will be always first, the element that arrived before will be second, etc.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Vision.MyKMeansWM.MyKMeansWMReSortOutputTask.Reshuffle_Mat(GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single})">
            <summary>
              Change the ordering of vectors in Mat-matrix based on the indexes in IdxOrdering
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySaccade">
             <author>GoodAI</author>
             <meta>jk</meta>
             <status> Working </status>
             <summary>
               Select input patch/segment/object for Saccadic movement...
             </summary>
             <description>
               The node process set of hypothezied objects. Score each of them how likely it can be selected and selects the one.
               <h4> Input </h4>
               <ul>
                 <li>Patches:   [nx3]   matrix of x,y,scale of N patches/superpixels/objects. (-1 are ignored)</li>
                 <li>Desc:      [nxdim] descriptor of each path/superpixel/objects.</li>
                 <li>Mask:      [axb]   image where each pixels value corresponds to the segmetn id of the pixel.</li>
                 <li>ForcedXYS: [3x1]   force the output.</li>
               </ul> 
               
               <h4> Output </h4>
                 Postion and size of the selected object/patch.
            
              <h4> Parameters </h4>
               <ul>
                 <li> Time Term / IncreaseOnFocus: How much to skip the object that the node selected last time.</li>
                 <li> Time Term / DecreaseInTime: How long it will take to again look on the patch the node selected before.</li>
                 <li> Terms Weighting / RationSupportMovement: How much favor moving elements.</li>
               </ul>
                 
             
             </description>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySaccade.MySaccadeInitTask">
            <summary>
            Set default values for enery terms. It is done only once.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySaccade.MySaccadeUpdateTask">
            <summary>
            Update terms based on the actual inputs -> now we have id of min energy.
              <h4> Paramters </h4>
              <ul>
                <li> IncreaseOnFocus:       Term increase when focuser selects it. Lower will stay on the object longer.</li>
                <li> DecreaseInTime:        Ration for decresing time term in time. Higher will try to go back on the seen patch sooner.</li>
                <li> RationSupportMovement: How much to prefer movement against time.</li>
            </ul>
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Vision.MySaccade.MySaccadeUpdateTask.EstimateRealNumOfPatches">
            <summary>
            Find where zeros start -> this estimates # of patches...
            </summary>
            <returns></returns>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySaccade.MySaccadeConvertOutId2XYTask">
            <summary>
            Convert id into a xy+scale and set it as the output
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySegment">
            <author>GoodAI</author>
            <meta>jk</meta>
            <status> Working </status>
            <summary>
              Segment image into a set of superpixels. The code is restriceted to square images and specific nSegments values.
            </summary>
            <description>
              Takes image (RGB or just Black and White if G/B input channels are left free) as an input and runs SLIC algorithm [1] to find segments. The code is calling the GPU version [2] of the 
              SLIC method [1].
              
              <h4> Input</h4>
                Image. When it is gray, use only the first branch.
              
              <h4> Output</h4>
              <ul>
                <li> SP_xy:    Center of each superpixel (segment) [x,y,nPts]  (need #of pts). It has size nSeg x 3.</li>
                <li> SP_desc:  Descriptor [r,g,b,movement] it has size nSeg x 4.</li>
                <li> Mask:     Mask where the value of each pixel has segmentId. it has size of the input image.</li>
              </ul>
              
              <h4> Parameters </h4>
              <ul>
                <li> nSegs:  Number of segmetns. Try to keep number such that int n exist: nSegs=n*n; Higher->faster.</li>
                <li> Weight: Whether segmetns should prefer grid structure. 0.9 works the best for fishes, while 0.3 for phong.</li>
                <li> nIters: Number of iterations. Something between 1-3 is usally more than enough.</li>
              </ul>
              
              <h4>Restrictions</h4>
              <ul>
                <li> The width of the image has to correspond to its height.</li>
                <li> If n is number of segments, there has to exist integer k such that k*k=n.</li>
                <li> It is better to keep the number of segments per rows/columns nicely exactly divided by the number of pixels per row/column.</li>
              </ul>
              
              <h4>Observer</h4>
               When the observer is used to visualize the result, you can change Operation/ObserverMode to change what is shows:
              <ul>
                <li> Image with borders of segments</li>
                <li> only borders of segmetns</li>
                <li> XYZ space of colors</li>
                <li> id of segments </li>
                <li> id os segments normalized for beter view </li>
                <li> center of each segment</li>
             </ul>
             
            <h4>References</h4>
            [1] Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine Süsstrunk, SLIC Superpixels Compared to State-of-the-art Superpixel Methods, PAMI vol. 34, num. 11, p. 2274 - 2282, May 2012.<br></br>
            [2] <a href="https://github.com/painnick/gSLIC"> gSLIC is an GPU implementation of Simple Iterative Linear Clustering (SLIC) superpixel segmentation algorithm. </a>. Online avelaible June, 2015
            
            </description>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySegment.MySLICTask">
            <summary>
            Run SLIC algorithm that calculates segments.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.Vision.MySegment.MyCalcDescTask">
            <summary>
            Calculate desriptor - it has color desc and movement (differnece to previous result). Also commented code for soemthing with edges, but it is useless and should be done in a better way.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert1To2(System.String)">
            <summary>
            Convert RandomMapper task name and property names
            Author: Martin Milota
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert2To3(System.String)">
            <summary>
            Big fat conversion of old namespace names
            Author: Dusan Fedorcak
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert3To4(System.String)">
            <summary>
            Move random node to proper namespace
            Author: MB
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert4To5(System.String)">
            <summary>
            Convert LSTM delta tasks
            Author: KK
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert5To6(System.String)">
            <summary>
            Convert LSTM activation function property names
            Author: KK
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert6To7(System.String)">
            <summary>
            Convert version 6->7
            Author: Vision 
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert7To8(System.String)">
            <summary>
            split focuser and unfocus :)
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert8To9(System.String)">
            <summary>
            QLearning tasks refactoring
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert9To10(System.String)">
            <summary>
            Convert MyRandomNode task to multiple mutually exclusive tasks
            Author: MV
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert10To11(System.String)">
            <summary>
            Convert MyRandomNode Period to dummy task so it can be changed runtime
            Author: MV
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert11To12(System.String)">
            <summary>
            Convert MyDistanceNode's inputs from A,B to Input 1, Input 2 (required after the node was put into Transforms)
            Author: MP
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert12To13(System.String)">
            <summary>
            Convert (Min/Max)Index to Abs(Min/Max)Index
            Author: JK
            </summary>
        </member>
        <member name="M:GoodAI.Modules.Versioning.MyConversion.Convert13To14(System.String)">
            <summary>
            Convert Observer names for DiscreteQLearning and Harm
            Author: JV,PD
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.Hashes.MyHashingMemory">
            <author>GoodAI</author>
            <meta>mm</meta>
            <status>WIP</status>
            <summary>A large vector -- memory -- that can be updated by adding a vector of values to specific indices.</summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.VSA.Hashes.MyHashingMemory.RandomInitTask">
            <summary>
            Randomly initializes the contents of the memory.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.Hashes.MyHashingMemory.MyAddToIndicesTask">
            <summary>
            Performs the mapping to the memory.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.Hashes.MyHashMapper">
             <author>GoodAI</author>
             <meta>mm</meta>
             <status>working</status>
             <summary>Constructs an index key for every element of the input. The range of the indices is [0, OutputBinCount).</summary>
             <description>
            
             <h3> Features: </h3>
             Transforms each input value to an index depending on the mode:
             <ol>
                 <li><h4>Simple:</h4></li>
                 <ul>
                     <li>Determinalistically randomizes bits in the output via <a href="https://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3</a>.</li>
                     <li>Modulates the output to the integer interval <code>[0, <i>OutputBinCount</i>)</code>.</li>
                 </ul>
             
                 <li><h4>Locality-sensitive</h4> (due to Datar-Immorlica-Indyk-Mirrokni’04):</li>
                 <ul>
                     <li>Inputs should floating point numbers from <code>[-1, 1]</code>.</li>
                     <li>If <i>UseOffsets</i> is true, adds precomputed random values from <code>[0, 2]</code> to the corresponding inputs.</li>
                     <li>Modulates the results by 2.</li>
                     <li>Divides by <code>2/<i>InternalBinCount</i></code> and truncates to get the integer index of the bin.</li>
                     <li>If <i>DoHashing</i> is true, hashes these values to <code>[0, <i>OutputBinCount</i>)</code> via Simple hashing.</li>
                     <li>If <i>DoHashing</i> is false, hashes values to <code>[0, <i>InternalBinCount</i>)</code> and offsets them by <code>i*<i>InternalBinCount</i></code>, where <code>i</code> is the value's index in the vector.
                         WARNING: This results in output index range in <code>[0, <i>Input.Count</i>*<i>InternalBinCount</i>)</code>.</li>
                 </ul>
             </ol>
              
             <h3> Important notices: </h3>
             <ul>
                 <li>OutputBinCount must be a power of 2 for now.</li>
                 <li>Consider using the RandomMapper node to change the dimensionality of the inputs (can be handy for more benevolent locality-sensitive hashing).</li>
                 <li>Use the RandomMapper node first if you want the inputs' values to be connected -- slightly changing a single value will then affect all the output indices.</li>
             </ul>
             </description>
        </member>
        <member name="T:GoodAI.Modules.VSA.Hashes.MyHashMapper.MyHashMapperTask">
            <summary>
            Performs the hash mapping.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.Hashes.MyHashMapper.MyHashMapperTask.GetIndices(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Nullable{ManagedCuda.BasicTypes.CUdeviceptr},System.Int32,System.Int32,System.Int32,GoodAI.Core.MyCudaKernel,GoodAI.Core.MyCudaKernel,GoodAI.Core.MyCudaKernel,System.Boolean,System.Int32,ManagedCuda.CudaStream)">
            <summary>
            Transforms the <paramref name="output"/> vector into a vector of indices with properties specified by the parameters.
            </summary>
            <param name="input">The vector to transform.</param>
            <param name="output">The memory to contain the results.</param>
            <param name="misc">A vector containing the range to modulate to as the first value (typically 2f because dot product ranges from [-1,1])
            and the bin size in this modulated space (typically <paramref name="misc"/>[0] / internalBinCount) as the second value.</param>
            <param name="offsets">The random offsets for each <paramref name="output"/> value (typically uniform random numbers in [0, <paramref name="misc"/>[0].</param>
            <param name="vectorSize">The length of the <paramref name="output"/> vector.</param>
            <param name="outputBinCount">The range into which the internal bins will be scattered.</param>
            <param name="seed">The seed used for the scattering the internal bins.</param>
            <param name="combineVectorsKernel">The kernel used for addition, modulo and integer division.</param>
            <param name="hashKernel">The kernel used for scattering the internal bins.</param>
            <param name="noHashKernel"></param>
            <param name="doHashMapping"></param>
            <param name="internalBinCount"></param>
            <param name="stream"></param>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyCombinationBook">
            <author>GoodAI</author>
            <tag>#mm</tag>
            <status>Not Optimized</status>
            <summary>
              Generates static random permutations with either a single cycle or random cycles.
              Optionally, generates random combinations with either unique numbers or allowed duplicates.
            </summary>
            <description>
              A single cycle is created by applying the Sattolo's shuffle (as seen <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Sattolo.27s_algorithm">here</a>). 
              Random cycles are created by using the Fisher-Yates shuffle (as seen <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_.22inside-out.22_algorithm">here</a>).
              Use the <see cref="P:GoodAI.Modules.VSA.MyCombinationBook.Power"/> property to pre-compute a desired power of the base permutation.
            </description>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBook.GetPowerString(System.Int32)">
            <summary>
            Returns a superscript string representing the parameter.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBook.MakePower(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaDeviceVariable{System.Single},GoodAI.Core.MyCudaKernel,System.Int32,System.Int32)">
            <summary>
            Applies the <paramref name="multKernel"/> operation on <paramref name="identity"/> and <paramref name="codeVector"/> <paramref name="power"/>-times.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyCombinationBook.MyInitMemTask">
            <summary>
              Initializes all the memory needed for creating combinations.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyCombinationBook.MyMakePowerTask">
            <summary>
              Copies combinations to the output
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBase.ShuffleSattolo(System.ArraySegment{System.Single},System.Random,System.Boolean)">
            <summary>
            Shuffles a part of a sequence. The permutation in the segment has only one cycle (there are (n-1)! such permutations).
            For more information see http://en.wikipedia.org/wiki/Fisher–Yates_shuffle#Sattolo.27s_algorithm
            </summary>
            <param name="seq">The segment to be shuffled.</param>
            <param name="rnd">The random number generator used to permute the sequence.</param>
            <param name="inPlaceInit">If true, will generate a permutation of numbers from (0, seq.Count - 1). Otherwise, it will permute the original sequence.</param>
            <returns>The random permutation.</returns>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBase.ShuffleFisherYates(System.ArraySegment{System.Single},System.Random,System.Boolean)">
            <summary>
            Shuffles a part of a sequence. The permutation in the segment has random cycles (there are n! such permutations).
            For more information see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_.22inside-out.22_algorithm
            </summary>
            <param name="seq">The segment to be shuffled.</param>
            <param name="rnd">The random number generator used to permute the sequence.</param>
            <param name="inPlaceInit">If true, will generate a permutation of numbers from (0, seq.Count - 1). Otherwise, it will permute the original sequence.</param>
            <returns>The random permutation.</returns>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBase.GenerateCombinationUnique(System.ArraySegment{System.Single},System.Collections.Generic.HashSet{System.Single},System.Int32,System.Int32,System.Random)">
            <summary>
            Generates unique random numbers in the range [<paramref name="min"/>, <paramref name="max"/>), where min is inclusive and max is exclusive and stores them in <paramref name="arr"/>.
            For more information see http://codereview.stackexchange.com/a/61372
            </summary>
            <param name="arr">The array to store the resulting combinations in. The whole array will be populated.</param>
            <param name="candidates">The temporary hash table to store intermediate results in.</param>
            <param name="min">The minimum value of a resulting element.</param>
            <param name="max">The maximum value of a resulting element.</param>
            <param name="rnd">The random number generator used to permute the sequence.</param>
            <returns>The random sample.</returns>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyCombinationBase.GenerateCombination(System.ArraySegment{System.Single},System.Int32,System.Int32,System.Random)">
            <summary>
            Generates non-unique random numbers in the range [<paramref name="min"/>, <paramref name="max"/>), where min is inclusive and max is exclusive and stores them in <paramref name="arr"/>.
            </summary>
            <param name="arr">The array to store the resulting combinations in. The whole array will be populated.</param>
            <param name="min">The minimum value of a resulting element.</param>
            <param name="max">The maximum value of a resulting element.</param>
            <param name="rnd">The random number generator used to permute the sequence.</param>
            <returns>The random sample.</returns>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyCodeBook">
            <author>GoodAI</author>
            <tag>#mm</tag>
            <status>Working</status>
            <summary>
              Static symbol table shared between all nodes of the same SymbolSize.
              Use Mode to specify whether to generate a symbol or test it through dot product with the input.
            </summary>
            <description>
              Pre-computes vectors that are shared between nodes of this type that have the same SymbolSize.
            </description>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyCodeBook.MyCodeVectorsTask">
            <summary>
              Select pre-computed random vectors by using the CodeVector property.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyBindingNode">
            <author>GoodAI</author> 
            <tag>#mm</tag>
            <status>Working</status>
            <summary>
              Provides the Bind and Unbind operations for HRR or BSC symbols, as well permuting. The implementation for HRR is based on the fast Fourier transformation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyBindingNode.MyBindingTask">
            <summary>
              Performs the binding or unbinding operation.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyRandomMapper">
            <author>GoodAI</author>
            <tag>#mm</tag>
            <status>Working</status>
            <summary>
              Performs a random projection to another dimension by computing A.x with a random matrix A and the input vector x.
              The transformation matrix is shared with nodes that do the same transformation (including its inverse, see <see cref="P:GoodAI.Modules.VSA.MyRandomMapper.DoDecoding"/>)
              and have the same <see cref="P:GoodAI.Modules.VSA.MyRandomMapper.NameGroup"/>. You can select which matrix axis to normalize to produce vectors of different lengths.
            </summary>
            <description></description>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyRandomMapper.MyGenerateMatrixTask">
            <summary>
              Allocates all the memory needed to store and create the desired transformation matrices and generates them based on the selected settings.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyRandomMapper.MyRandomMapperTask">
            <summary>
              Transforms the input by the transformation matrix as specified by the parameters.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.GenerateRandomNormalVectors(System.Single[],System.Random,System.Int32,System.Int32,System.Single,System.Double,System.Boolean,System.Random,System.Single)">
            <summary>
            Fills the <paramref name="codeVectors"/> array with <paramref name="otherDim"/> random normally distributed vectors with size <paramref name="leadingDim"/>, zero mean and variance 1/<paramref name="var"/>.
            Each vector is normalized to unit length. Use the <paramref name="oneToZeroRatio"/> parameter to specify the sparseness of the vectors.
            <paramref name="otherDim"/> shall be the leading dimension of the resulting matrix.
            </summary>
            <param name="codeVectors">The array to populate by the random normal vectors.</param>
            <param name="random">The random object used to generate vector elements.</param>
            <param name="leadingDim">The size of each vector.</param>
            <param name="otherDim">The number of vectors to be generated.</param>
            <param name="mean">The expected mean of the generated values. Defaults to zero.</param>
            <param name="var">The variance of the generated values. If not specified or non-positive variance is passed, the value 1/xDim will be used to generate approximately normalized vectors.</param>
            <param name="normalize">Specifies whether each generated vector should be normalized to unit length.</param>
            <param name="oneToZeroRandom">The random object used to decide the sparseness of the vectors. If null is passed, <paramref name="oneToZeroRatio"/> is set to 1.</param>
            <param name="oneToZeroRatio">The ratio of non-zero elements to zeros.</param>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.GenerateRandomBSCVectors(System.Single[],System.Random,System.Single)">
            <summary>
            Fills the <paramref name="codeVectors"/> array with random binary numbers.
            Use the <paramref name="oneToZeroRatio"/> parameter to specify the sparseness of the vectors.
            </summary>
            <param name="codeVectors">The array to populate by the random binary vectors.</param>
            <param name="random">The random object used to decide the sparseness of the vectors. If null is passed, <paramref name="oneToZeroRatio"/> is set to 1.</param>
            <param name="oneToZeroRatio">The ratio of non-zero elements to zeros.</param>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.Transpose(System.Single[]@,System.Int32,System.Int32)">
            <summary>
            Transposes the matrix with dimensions specified by <paramref name="xDim"/> and <paramref name="yDim"/>.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.NormalizeLeadingDim(System.Single[],System.Int32,System.Int32)">
            <summary>
            Normalizes vectors along the leading dimension.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.NormalizeLeadingDim(GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Int32,System.Int32,GoodAI.Modules.Transforms.MyProductKernel{System.Single},GoodAI.Core.MyCudaKernel,System.Int32)">
            <summary>
            Normalizes vectors along the leading dimension.
            </summary>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.GenerateTransformMatrix(System.Random,System.Int32,System.Int32,System.Boolean,GoodAI.Modules.VSA.MyRandomPool.AxisToNormalizeEnum)">
            <summary>
            Generates a matrix with <paramref name="yDim"/> being the leading dimension in column-major storage.
            </summary>
            <param name="random">The random object for number generation.</param>
            <param name="xDim">The size of the leading dimension.</param>
            <param name="yDim">The size of the other dimension.</param>
            <param name="orthonormalize">If true, the vectors along the longer dimension will be orthonormalized.</param>
            <param name="axisToNormalize">The axis along which to normalize vectors after orthonormalization.</param>
            <returns>The generated matrix.</returns>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.GenerateTransformMatrix(GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Random,System.Int32,System.Int32,GoodAI.Modules.Transforms.MyProductKernel{System.Single},GoodAI.Core.MyCudaKernel,GoodAI.Core.MyCudaKernel,System.Int32,GoodAI.Modules.VSA.MyRandomPool.VectorGenerationMode,GoodAI.Modules.VSA.MyRandomPool.AxisToNormalizeEnum)">
            <summary>
            Generates a matrix with <paramref name="xDim"/> being the leading dimension in column-major storage.
            </summary>
            <param name="unmanagedVectors">A memory block to store the generated matrix.
            Must be as large as <paramref name="xDim"/> x <paramref name="yDim"/>.</param>
            <param name="unmanagedBaseVectors">A temporary block to store all the base vectors.
            Must be as large as Max(<paramref name="xDim"/>, <paramref name="yDim"/>)^2.
            Only neccessary when <paramref name="mode"/> is set to <see cref="F:GoodAI.Modules.VSA.MyRandomPool.VectorGenerationMode.AverageBaseVectors"/>.</param>
            <param name="temp">The temporary storage. It should be as long as the longer of the dimensions.</param>
            <param name="random">The random object for number generation.</param>
            <param name="xDim">The size of the other dimension.</param>
            <param name="yDim">The size of the leading dimension.</param>
            <param name="mode">If true, the vectors along the longer dimension will be orthonormalized.</param>
            <param name="axisToNormalize">The axis along which to normalize vectors after orthonormalization.</param>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.DotProduct(System.ArraySegment{System.Single},System.ArraySegment{System.Single})">
            <summary>
            Computes the inner product of two vectors specified by the array segments.
            </summary>
            <param name="first">The first vector of the inner product.</param>
            <param name="second">The second vector of the inner product.</param>
            <returns>The inner products of the given vectors.</returns>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.OrthonormalizeVectors(System.Single[],System.Int32,System.Int32)">
            <summary>
            Transforms all the vectors stored in <paramref name="vectors"/> to be pair-wise orthonormal using a modified version of the Gram-Schmidt algorithm.
            </summary>
            <param name="vectors">The vectors to orthonormalize.</param>
            <param name="xDim">The length of each vector.</param>
            <param name="yDim">The number of vectors.</param>
        </member>
        <member name="M:GoodAI.Modules.VSA.MyRandomPool.OrthonormalizeVectors(GoodAI.Core.Memory.MyMemoryBlock{System.Single},GoodAI.Core.Memory.MyMemoryBlock{System.Single},System.Int32,System.Int32,GoodAI.Modules.Transforms.MyProductKernel{System.Single},GoodAI.Core.MyCudaKernel,System.Int32)">
            <summary>
            Transforms all the vectors stored in <paramref name="vectors"/> to be pair-wise orthonormal using a modified version of the Gram-Schmidt algorithm.
            </summary>
            <param name="vectors">The vectors to orthonormalize.</param>
            <param name="temp">A vector of temporal space.</param>
            <param name="xDim">The length of each vector.</param>
            <param name="yDim">The number of vectors.</param>
            <param name="dotKernel">The kernel to compute a dot product.</param>
            <param name="multKernel">The kernel to compute vector combinations.</param>
        </member>
        <member name="T:GoodAI.Modules.VSA.MySpatialCoder">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>working</status>
            <summary>Encodes &amp; decodes spatial values into symbols through linear interpolation.</summary>
            <description>
            
            <h3> Features: </h3>
            Transforms the input based on one of the following modes:
            <ol>
                <li><h4>Encode:</h4></li>
                <ul>
                    <li>Expects (or rather works best with) a vector of floats in the real interval <code>[-1, 1]</code>. Note that a maximum of 2 numbers can be encoded with this node.</li>
                    <li>For the value <code>t</code> in each dimension, computes the encoding as</li>
                        <code>t*dir + (1-t)*o</code>,<br/>
                        where <code>dir</code> is either <code>negDir</code> if <code>t&lt;0</code> or <code>posDir</code> otherwise.
                        Vectors <code>negDir</code>, <code>posDir</code> and <code>o</code> are random precomputed symbolic
                        constants specific for the dimension (globally shared -- you can access them via the CodeBook node).
                    <li>Superposes the encodings for each dimension and outputs it.</li>
                </ul>
            
                <li><h4>Decode:</h4></li>
                <ul>
                    <li>Expects a vector s with superposed values encoded by this node.</li>
                    <li>For each dimension of the output, computes</li>
                        <code>s.posDir - s.negDir = s.dir</code> (the symbol . denoting the dot product).<br/>
                        Note that one of the values <code>s.posDir</code> or <code>s.negDir</code> will be zero.
                    <li>Computes the reliability of the decoding as</li>
                        <code>rel = s.o + s.dir</code><br/>
                        This value indicates the amount of noise in the input vector (since for orthogonal
                        <code>o</code> and <code>dir</code> and no noise in the superposition, <code>rel</code> should sum up to 1).
                    <li>Outputs the value</li>
                        <code>output = s.dir / rel</code><br/>
                        as the result of decoding for the corresponding dimension.
                    <br/>
                    <h4>Sidenotes:</h4>
                    <li>Let's say that</li> 
                        <code>s = dir*t + o*(1-t) + noise</code>
                    <li>We then get:</li>
                        <code>s.dir &#160;&#160;= dir.dir*t + o.dir*(1-t) + dir.noise = t + 0 + dir.noise</code><br/>
                        <code>s.o &#160;&#160;&#160;&#160;= o.dir*t &#160;&#160;+ o.o*(1-t) &#160;&#160;+ o.noise &#160;&#160;= 0 + (1-t) + o.noise</code><br/>
                        <code>output &#160;= t + dir.noise / (1 + dir.noise + o.noise)</code>
                    <li>Now <code>dir.noise</code> and <code>o.noise</code> should be very close to zero. This decoding approach should make
                        the decoding more precise when <code>noise</code> is has a similar dot product to <code>dir</code> and <code>o</code>.</li>
                </ul>
            </ol>
            
            <h3> Important notices: </h3>
            <ul>
                <li>This node splits the interval <code>[-1, 1]</code> into two parts and interpolates in each of them.
                    To split the interval into arbitrarily many parts, use the SpatialGrid node.
                    The benefit is that the hyperspace gets more evenly occupied by interpolating between many more than 3 points,
                    but the computation is much more intensive, because we are working with many more vectors.</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.VSA.MySpatialCoder.MySpatialCoderTask">
            <summary>
            Performs the encoding or decoding of the input.
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MySymbolicGrid">
            <author>GoodAI</author>
            <meta>df, rb</meta>
            <status>Working, binary symbols not implemented</status>
            <summary>Symbolic representataion of uniform square grid.
            Will be used for storing spatial data into symbols.</summary>
            <description>
            Parameters:<br />
            <ul>
            <li>X_POINTS - number of points (symbols) on the X-axis</li>
            <li>Y_POINTS - number of points (symbols) on the Y-axis</li>
            <li>SYMBOL_COUNT - overall number of symbols (X_POINTS + Y_POINTS), read only</li>
            <li>Mode - mode of the symbolic grid mode: Encode - encode x and y to the symbol, Decode - decode symbol to the x and y positions, Cleanup - clean symbol on the input</li>
            </ul>
            </description>
        </member>
        <member name="T:GoodAI.Modules.VSA.MySymbolicGrid.MyInitGridTask">
            <summary>
            Initialization task for symbolic grid node<br />
            The space is discretized and symbols are generated
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MySymbolicGrid.MySymbolizePositionTask">
            <summary>
            According to the Mode set in the node parameters, this tasks provides encoding, decoding or cleaning up the symbol<br />
            Parameters:<br />
            <ul>
            <li>X_MAX: maximum possible value on the x-axis (encodes interval  &lt;0,X_MAX &gt;)</li>
            <li>Y_MAX: maximum possible value on the y-axis (encodes interval  &lt;0,Y_MAX &gt;)</li>
            </ul>
            </summary>
        </member>
        <member name="T:GoodAI.Modules.VSA.MyTransformLearningNode">
            <author>GoodAI</author>
            <meta>ph</meta>
            <status>Working</status>
            <summary>Learning transformations of Symbolic Pointers with gradient method</summary>
            <description>Works (probably) only on linear transformations</description>
        </member>
        <member name="T:GoodAI.Core.Nodes.MySignalToFloatNode">
            <author>GoodAI</author>
            <meta>jv</meta>
            <status>Working</status>
            <summary>Reads the signal from the data and converts it to the output float.</summary>
            <description>Converts chosen type of the signal to output value: signal IsIncommingRised means 1 on output, 0 otherwise.</description>
        </member>
        <member name="T:GoodAI.Core.Nodes.MySignalToFloatNode.SignalToFloatTask">
            <summary>
            Read the signal and convert it to the float value on the output.
            </summary>
        </member>
        <member name="T:GoodAI.Core.Nodes.MySignalNode">
            <author>GoodAI</author>
            <meta>df</meta>
            <status>Working</status>
            <summary>Alters signal on the data connection according to signal input.</summary>
            <description>Select a signal name and threshold to raise/drop selected signal on the data output.</description>
        </member>
        <member name="M:GoodAI.BasicNodes.DiscreteRL.Observers.IDiscretePolicyObservable.ReadTwoDimensions(System.Single[0:,0:]@,System.Int32[0:,0:]@,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Method creates 2D array of max action utilities and max action labels over across selected dimensions.
            The values in the memory are automatically scaled into the interval 0,1. Realtime values are multiplied by motivations.
            </summary>
            <param name="values">array passed by reference for storing utilities of best action</param>
            <param name="labelIndexes">array of the same size for best action indexes</param>
            <param name="XVarIndex">global index of state variable in the VariableManager</param>
            <param name="YVarIndex">the same: y axis</param>
            <param name="showRealtimeUtilities">show current utilities (scaled by the current motivation)</param>
            <param name="policyNumber">optinal parameter. In case that the agent has more strategies, you can choose which one to read from.</param>
        </member>
        <member name="M:GoodAI.BasicNodes.DiscreteRL.Observers.IDiscretePolicyObservable.GetActionLabels">
            <summary>
            Return list of action labels.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GoodAI.BasicNodes.DiscreteRL.Observers.IDiscreteSRPObservable">
            <summary>
            Interface for HARM
            </summary>
        </member>
        <member name="M:GoodAI.BasicNodes.DiscreteRL.Observers.IDiscreteSRPObservable.GetPredictorNo(System.Int32)">
            <summary>
            return StochasticReturnPredictor given by its index
            </summary>
            <param name="ind"></param>
            <returns></returns>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Layers.MyActivationLayer">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>WIP</status>
            <summary>Activation layer.</summary>
            <description>Activation layer of the NN group.</description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyPoolingForwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Performs MAX pooling forward pass. Chooses the max value from each receptive field and its each position (determined by FilterW/H and Stride parameters).
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyPoolingBackwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Propagates deltas back through the pooling layer.
            The chosen max value is saved in each forward pass and used in this backward pass to determine the neuron that will receive the delta.
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyConvolutionForwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Standard forward pass of the convolution operation.
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyConvolutionBackwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Computes deltas of the previous layer from deltas on this convolutional layer.
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyConvolutionInitLayerTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Randomly initialises weights and biases of the convolution layer.
            Uses normal distribution with standard deviation of 1 / (sqrt(input.Count))
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.NeuralNetwork.Tasks.MyConvolutionUpdateWeights">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            Updates the weights (filters) of this convolutional layer. The exact algorithm to be used is chosen using the parent network's settings.
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.RBM.Tasks.MyRBMInputForwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            <p>
            Simple input forward tasks that copies input to output.
            </p>
            <br></br>
            <p>
            Does not have to be checked/used when RBM task is active.
            MUST be checked/used when the group is doing an SGD-type task.
            </p>
            </summary>
            <description></description>
        </member>
        <member name="T:CustomModels.RBM.Tasks.MyRBMInputBackwardTask">
            <author>GoodAI</author>
            <meta>mz</meta>
            <status>Working</status>
            <summary>
            <p>
            Simple delta backprop tasks that copies output deltas to input deltas.
            </p>
            <br></br>
            <p>
            Does not have to be checked/used when RBM task is active.
            </p>
            </summary>
            <description></description>
        </member>
        <member name="T:HTSLmodule.Worlds.MyAnimationPredictionWorld">
            <author>GoodAI</author>
            <meta>CireNeikual,jv</meta>
            <status>Finished</status>
            <summary>Presents given sequence of image frames to the output.</summary>
            <description>The dataset can be used either default one or custom before the simulation. Here (compared to the ImageDatasetWorld), 
            the dataset can be updated at runtime (path to the images and their count). The only requirement is to preserve image resolution 
            chosen before the simulation.
            
            <h3>Parameters</h3>
            <ul>
                <li> <b>UseCustomDataset:</b> If true, the world will attempt to read dataset by given RootFileName, Digits, Extension and NumFrames.</li>
                <li> <b>NumFrames:</b> Number of frames to be loaded from the dataset (starting from 0) and sequentially presented to output.</li>
                <li> <b>RootFileName:</b> Defines path to the file and base part of the name. Name is composed as follows: [RootFineName][numDigits][Extension]. 
                Where items are numbered from 0.</li>
                <li> <b>Digits:</b> How many digits is in the filename? E.g. for 5 it is "RootFilename_00000.png", "RootFilename_00001.png", etc..</li>
                <li> <b>Extension:</b> E.g. ".png"</li>
            </ul>
            
            Note that the same parameters are in the Load task. This task can be run once for changing the dataset at runtime.
            </description>
        </member>
        <member name="T:HTSLmodule.Worlds.MyAnimationPredictionWorld.MyAnimationPredictionLoadTask">
            <summary>
            Tries to reload the images during the simulation. Old bitmaps are preserved if the attempt is unsuccessful and simulation continues.
            If loading is OK, task can be disabled again to increase the speed of simulation.
            </summary>
        </member>
        <member name="T:HTSLmodule.Worlds.MyAnimationPredictionWorld.MyAnimationPredictionPresentTask">
            <summary>
            Puts the current bitmap onto the output.
            </summary>
        </member>
    </members>
</doc>
